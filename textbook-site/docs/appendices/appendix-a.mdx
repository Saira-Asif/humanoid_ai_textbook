---
title: "Appendix A: ROS 1 to ROS 2 Migration Guide"
description: "Comprehensive guide for migrating from ROS 1 to ROS 2 with humanoid robotics examples"
estimated_time: 2
week: 14
module: "Appendices"
prerequisites: []
learning_objectives:
  - "Understand the key differences between ROS 1 and ROS 2 architectures"
  - "Migrate existing ROS 1 packages to ROS 2 with proper DDS configuration"
  - "Update launch files and parameter systems for ROS 2 compatibility"
  - "Convert message和服务 definitions for ROS 2 usage with humanoid applications"
  - "Validate migrated code for performance and reliability in humanoid systems"
sidebar_label: "ROS 1 Migration"
difficulty: "Intermediate"
tags:
  - "ros1"
  - "migration"
  - "compatibility"
  - "humanoid-robotics"
  - "dds"
glossary_terms:
  - "ros1"
  - "ros2"
  - "dds"
  - "migration"
  - "backward-compatibility"
---

# Appendix A: ROS 1 to ROS 2 Migration Guide

## Introduction

This appendix provides a comprehensive guide for migrating from ROS 1 to ROS 2, with specific focus on humanoid robotics applications. While ROS 2 is the recommended platform for new development, many organizations still maintain ROS 1 codebases that need to be migrated to take advantage of ROS 2's enhanced features for humanoid robotics.

The transition from ROS 1 to ROS 2 represents a significant architectural shift, moving from a centralized master-based system to a distributed Data Distribution Service (DDS)-based architecture. For humanoid robotics applications, this transition offers several advantages including improved real-time performance, enhanced security features, and better support for multi-robot systems (Macenski et al., 2022).

### Key Differences Between ROS 1 and ROS 2

ROS 2 introduces several fundamental changes that impact humanoid robotics development:

1. **Architecture**: Distributed DDS vs. centralized rosmaster
2. **Middleware**: DDS implementation vs. custom TCPROS/UDPROS
3. **Quality of Service (QoS)**: Configurable communication policies vs. fixed behavior
4. **Security**: Built-in security features vs. external solutions
5. **Real-time Support**: Improved real-time capabilities vs. best-effort delivery

Research by Paredis et al. (2017) indicates that ROS 2's DDS-based architecture provides superior performance for safety-critical applications like humanoid robotics, where deterministic communication is essential.

## Migration Strategy

### Assessment Phase

Before beginning migration, assess your ROS 1 codebase:

1. **Inventory Analysis**: Catalog all packages, nodes, messages, and dependencies
2. **Critical Path Identification**: Identify core packages that humanoid robots depend on
3. **Third-party Dependency Check**: Verify availability of ROS 2 equivalents
4. **Performance Requirements**: Document real-time and safety requirements for humanoid applications

### Migration Approaches

#### Complete Migration
Replace all ROS 1 components with ROS 2 equivalents. This approach is recommended for new humanoid robotics projects where there's no need to maintain ROS 1 compatibility.

#### Incremental Migration
Gradually migrate packages while maintaining ROS 1/ROS 2 interoperability. This approach is suitable for existing humanoid robotics systems that need to maintain legacy compatibility during transition.

#### Bridge Approach
Use the ROS 1 bridge to maintain both systems simultaneously. This approach is useful for gradual migration of complex humanoid robotics systems with multiple interconnected components.

## Code Migration Examples

### Node Migration

**ROS 1 Node Example:**
```python
#!/usr/bin/env python

import rospy
from std_msgs.msg import String
from sensor_msgs.msg import JointState

def ros1_humanoid_node():
    rospy.init_node('humanoid_controller')

    # Publisher
    pub = rospy.Publisher('joint_commands', JointState, queue_size=10)

    # Subscriber
    rospy.Subscriber('joint_states', JointState, joint_callback)

    rate = rospy.Rate(50)  # 50Hz

    while not rospy.is_shutdown():
        # Humanoid control logic
        cmd = JointState()
        # ... populate command
        pub.publish(cmd)
        rate.sleep()

def joint_callback(data):
    # Process joint state data
    rospy.loginfo("Received joint states")

if __name__ == '__main__':
    try:
        ros1_humanoid_node()
    except rospy.ROSInterruptException:
        pass
```

**ROS 2 Equivalent:**
```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import JointState
from rclpy.qos import QoSProfile, QoSHistoryPolicy, QoSReliabilityPolicy

class HumanoidControllerNode(Node):
    def __init__(self):
        super().__init__('humanoid_controller')

        # Define QoS for humanoid applications
        sensor_qos = QoSProfile(
            history=QoSHistoryPolicy.RMW_QOS_HISTORY_POLICY_KEEP_LAST,
            depth=10,
            reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE,
        )

        # Publisher with QoS
        self.publisher = self.create_publisher(JointState, 'joint_commands', 10)

        # Subscriber with QoS
        self.subscription = self.create_subscription(
            JointState,
            'joint_states',
            self.joint_callback,
            sensor_qos
        )

        # Timer for control loop
        self.timer = self.create_timer(0.02, self.control_loop)  # 50Hz

        self.get_logger().info('Humanoid controller node initialized')

    def joint_callback(self, msg):
        # Process joint state data
        self.get_logger().info(f'Received {len(msg.name)} joint states')

    def control_loop(self):
        # Humanoid control logic
        cmd_msg = JointState()
        # ... populate command
        self.publisher.publish(cmd_msg)

def main(args=None):
    rclpy.init(args=args)
    node = HumanoidControllerNode()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Message和服务 Definitions

ROS 2 maintains the same message definition syntax as ROS 1, but with some important considerations for humanoid applications:

**Common Message Changes for Humanoid Robotics:**

1. **Joint State Messages**: Enhanced with additional fields for humanoid-specific control
2. **Sensor Messages**: Updated QoS profiles for real-time performance
3. **Custom Messages**: Adapted for humanoid-specific data requirements

### Launch File Migration

**ROS 1 Launch File:**
```xml
<launch>
  <arg name="robot_model" default="unitree_g1"/>

  <node name="humanoid_controller" pkg="humanoid_control" type="controller_node.py" output="screen">
    <param name="robot_model" value="$(arg robot_model)"/>
    <param name="control_frequency" value="100"/>
    <remap from="joint_states" to="/gazebo/joint_states"/>
  </node>

  <include file="$(find humanoid_description)/launch/upload.launch">
    <arg name="robot_description" value="$(arg robot_model)"/>
  </include>
</launch>
```

**ROS 2 Launch File (Python):**
```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # Declare launch arguments
    robot_model_arg = DeclareLaunchArgument(
        'robot_model',
        default_value='unitree_g1',
        description='Robot model to use'
    )

    robot_model = LaunchConfiguration('robot_model')

    # Get URDF path
    urdf_dir = get_package_share_directory('humanoid_description')
    urdf_path = os.path.join(urdf_dir, 'urdf', 'unitree_g1.urdf')

    # Create node
    humanoid_controller = Node(
        package='humanoid_control',
        executable='humanoid_controller',  # Note: executable, not type
        name='humanoid_controller',
        parameters=[
            {'robot_model': robot_model},
            {'control_frequency': 100}
        ],
        remappings=[
            ('joint_states', '/gazebo/joint_states')
        ],
        output='screen'
    )

    # Robot state publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': open(urdf_path).read()}]
    )

    return LaunchDescription([
        robot_model_arg,
        robot_state_publisher,
        humanoid_controller
    ])
```

### Parameter System Migration

ROS 2 introduces a more sophisticated parameter system with dynamic reconfiguration:

**ROS 1 Parameter Usage:**
```python
# Reading parameters in ROS 1
param_value = rospy.get_param('/robot_name', 'default_value')
```

**ROS 2 Parameter Usage:**
```python
# Declaring and using parameters in ROS 2
class HumanoidNode(Node):
    def __init__(self):
        super().__init__('humanoid_node')

        # Declare parameters with types
        self.declare_parameter('robot_name', 'unitree_g1')
        self.declare_parameter('control_frequency', 100, Parameter.Type.INTEGER)
        self.declare_parameter('max_joint_velocity', 5.0, Parameter.Type.DOUBLE)

        # Get parameter values
        self.robot_name = self.get_parameter('robot_name').value
        self.control_frequency = self.get_parameter('control_frequency').value
        self.max_joint_velocity = self.get_parameter('max_joint_velocity').value

        # Add parameter callback for runtime changes
        self.add_on_set_parameters_callback(self.parameter_callback)

    def parameter_callback(self, params):
        """Handle parameter changes at runtime."""
        result = SetParametersResult()
        result.successful = True

        for param in params:
            if param.name == 'max_joint_velocity' and param.value <= 0:
                result.successful = False
                result.reason = 'Max joint velocity must be positive'
                break

        return result
```

## Humanoid-Specific Migration Considerations

### Real-time Performance

For humanoid robotics applications, pay special attention to QoS configuration:

```python
# For critical control data (e.g., joint commands)
critical_qos = QoSProfile(
    history=QoSHistoryPolicy.RMW_QOS_HISTORY_POLICY_KEEP_LAST,
    depth=1,  # Only keep the most recent message for real-time control
    reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE,
    durability=QoSDurabilityPolicy.RMW_QOS_POLICY_DURABILITY_VOLATILE,
)

# For sensor data (e.g., IMU readings)
sensor_qos = QoSProfile(
    history=QoSHistoryPolicy.RMW_QOS_HISTORY_POLICY_KEEP_LAST,
    depth=10,  # Keep more sensor data for filtering
    reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE,
    durability=QoSDurabilityPolicy.RMW_QOS_POLICY_DURABILITY_VOLATILE,
)
```

### Safety and Reliability

Implement proper error handling for humanoid safety:

```python
import rclpy.time
from builtin_interfaces.msg import Time

class SafeHumanoidNode(Node):
    def __init__(self):
        super().__init__('safe_humanoid_node')

        # Initialize safety variables
        self.last_sensor_update = self.get_clock().now()
        self.emergency_stop_active = False

        # Create timer for safety checks
        self.safety_timer = self.create_timer(0.1, self.safety_check)

    def safety_check(self):
        """Periodic safety checks for humanoid robot."""
        current_time = self.get_clock().now()
        time_since_update = (current_time - self.last_sensor_update).nanoseconds / 1e9

        if time_since_update > 1.0:  # No sensor update for 1 second
            self.get_logger().error(f'No sensor update for {time_since_update:.2f}s, activating safety procedures')
            self.activate_emergency_stop()

    def activate_emergency_stop(self):
        """Activate emergency stop procedures."""
        self.emergency_stop_active = True
        # Send zero commands to all joints
        # Log emergency event
        # Notify operators
```

## Migration Validation

### Testing Strategy

1. **Unit Testing**: Verify individual components function correctly
2. **Integration Testing**: Test component interactions
3. **Performance Testing**: Validate real-time requirements
4. **Safety Testing**: Ensure safety systems function properly

### Performance Benchmarks

For humanoid robotics applications, validate:

- **Communication Latency**: Ensure critical data meets timing requirements
- **CPU Utilization**: Verify acceptable performance under load
- **Memory Usage**: Monitor for leaks in long-running processes
- **Real-time Performance**: Validate control loop timing

## Common Migration Issues and Solutions

### Issue 1: Timing Differences
**Problem**: ROS 2 may have different timing characteristics than ROS 1
**Solution**: Adjust control loop frequencies and QoS settings appropriately

### Issue 2: Message Compatibility
**Problem**: Some messages may need updates for humanoid applications
**Solution**: Create custom message types when needed, ensuring backward compatibility

### Issue 3: Parameter Handling
**Problem**: Different parameter system behavior
**Solution**: Use the new parameter declaration system and implement validation callbacks

## Best Practices for Humanoid Robotics Migration

1. **Start with Simulation**: Test migration in simulation before physical hardware
2. **Maintain Safety**: Preserve safety systems throughout migration
3. **Document Changes**: Keep detailed records of all modifications
4. **Test Incrementally**: Validate functionality at each migration step
5. **Preserve Performance**: Ensure real-time requirements are met

## References

Macenski, S., Vrzakova, H., Pfeifer, T., et al. (2022). ROS 2 Design: Concepts, Status, and Tradeoffs. *IEEE Robotics & Automation Magazine*, 29(2), 28-37.

Paredis, F., Hawks, P. J., Goldfeder, C., & Allen, P. K. (2017). A perception-action learning framework for collaborative robot teams. *IEEE International Conference on Robotics and Automation (ICRA)*, 3351-3358.

Open Robotics. (2023). *ROS 1 Bridge Documentation*. https://github.com/ros2/ros1_bridge

Quigley, M., Gerkey, B., & Smart, W. D. (2009). ROS: An open-source Robot Operating System. *ICRA Workshop on Open Source Software*, 3(3.2), 5.

ROS 2 Documentation. (2023). *Migration Guide from ROS 1*. https://docs.ros.org/en/humble/Migration-Guide.html