---
title: "Chapter 3: URDF for Humanoids"
description: "Unified Robot Description Format for modeling humanoid robots in ROS 2"
estimated_time: 6
week: 4
module: "Module 1: ROS 2 Fundamentals"
prerequisites:
  - "intro"
  - "module-1-ros2/index"
  - "module-1-ros2/chapter1"
  - "module-1-ros2/chapter2"
learning_objectives:
  - "Create comprehensive URDF models for humanoid robots with proper kinematic chains"
  - "Configure joint limits, dynamics, and collision properties for humanoid-specific requirements"
  - "Integrate URDF models with ROS 2 visualization and control systems for humanoids"
  - "Validate URDF models using robot_state_publisher and TF transforms"
  - "Optimize URDF models for simulation and real-time control performance"
sidebar_label: "URDF Modeling"
difficulty: "Intermediate"
tags:
  - "urdf"
  - "robot-modeling"
  - "humanoid-robotics"
  - "kinematics"
  - "dynamics"
  - "visualization"
code_examples:
  total: 6
  languages:
    - "xml"
    - "python"
    - "bash"
    - "yaml"
related_chapters:
  - "module-1-ros2/chapter1"
  - "module-1-ros2/chapter2"
  - "module-2-digital-twin/chapter1"
appendix_references:
  - "appendix-a"
  - "appendix-c"
glossary_terms:
  - "urdf"
  - "xacro"
  - "tf-transforms"
  - "kinematic-chain"
  - "inertial-properties"
  - "collision-geometry"
---

# Chapter 3: URDF for Humanoids

## Introduction to URDF for Humanoid Robotics

Unified Robot Description Format (URDF) is the standard XML-based format for representing robot models in ROS. For humanoid robots, URDF becomes particularly important as it defines the complex kinematic structure, joint configurations, and physical properties required for realistic simulation and control. Unlike simpler robotic systems, humanoid robots have numerous degrees of freedom, complex kinematic chains, and specific anthropomorphic requirements that demand careful attention to URDF modeling.

Research by Quigley et al. (2009) demonstrates that accurate URDF models are fundamental to successful robot simulation and control, with errors in robot description leading to significant issues in motion planning and control. For humanoid robots with 20+ degrees of freedom, proper URDF modeling is essential for achieving stable locomotion and dexterous manipulation.

Humanoid-specific challenges in URDF modeling include:
- **Complex Kinematic Trees**: Multiple limbs with closed loops for hands/feet
- **Balance Requirements**: Precise center of mass and inertial properties
- **Anthropomorphic Constraints**: Joint limits that match human-like capabilities
- **Simulation Accuracy**: Proper collision and visual geometry for physics simulation

## URDF Fundamentals for Humanoid Robots

### URDF Structure and Components

A humanoid robot URDF consists of several key components that define its physical and kinematic properties:

```xml
<?xml version="1.0"?>
<robot name="unitree_g1_humanoid" xmlns:xacro="http://www.ros.org/wiki/xacro">

  <!-- Include material definitions -->
  <material name="black">
    <color rgba="0.0 0.0 0.0 1.0"/>
  </material>

  <material name="gray">
    <color rgba="0.2 0.2 0.2 1.0"/>
  </material>

  <!-- Base link - pelvis/trunk -->
  <link name="base_link">
    <inertial>
      <mass value="10.0"/>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>
    </inertial>

    <visual>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <geometry>
        <mesh filename="package://humanoid_description/meshes/base_link.STL"/>
      </geometry>
      <material name="gray"/>
    </visual>

    <collision>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <geometry>
        <mesh filename="package://humanoid_description/meshes/base_link_collision.STL"/>
      </geometry>
    </collision>
  </link>

  <!-- Example joint connecting base to another link -->
  <joint name="base_to_pelvis" type="fixed">
    <parent link="base_link"/>
    <child link="pelvis"/>
    <origin xyz="0 0 0" rpy="0 0 0"/>
  </joint>

</robot>
```

### Humanoid-Specific Considerations

When modeling humanoid robots in URDF, several anthropomorphic considerations must be addressed:

1. **Symmetry**: Humanoid robots typically have bilateral symmetry, which can be leveraged with xacro macros
2. **Degrees of Freedom**: Humanoid robots require 20+ joints for realistic movement
3. **Balance**: Proper mass distribution is critical for stable locomotion
4. **Manipulation**: Hand models require multiple fingers with appropriate DOF for dexterous manipulation

## Detailed Humanoid URDF Components

### Link Definition for Humanoid Components

Links represent rigid bodies in the robot. For humanoid robots, careful attention must be paid to mass distribution and inertial properties:

```xml
<!-- Pelvis link -->
<link name="pelvis">
  <inertial>
    <!-- Mass based on human proportions (approximately 8% of total body weight) -->
    <mass value="6.4"/>  <!-- Assuming 80kg humanoid -->
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <!-- Inertial tensor based on approximate box shape -->
    <inertia ixx="0.08" ixy="0" ixz="0" iyy="0.06" iyz="0" izz="0.04"/>
  </inertial>

  <visual>
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <geometry>
      <mesh filename="package://humanoid_description/meshes/pelvis.dae"/>
    </geometry>
    <material name="gray"/>
  </visual>

  <collision>
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <geometry>
      <mesh filename="package://humanoid_description/meshes/pelvis_collision.stl"/>
    </geometry>
  </collision>
</link>

<!-- Example thigh link for humanoid leg -->
<link name="left_thigh">
  <inertial>
    <!-- Mass based on human leg proportions (approximately 14% of total body weight per leg) -->
    <mass value="11.2"/>  <!-- Approximately half of leg mass -->
    <origin xyz="0 0 -0.18" rpy="0 0 0"/>  <!-- Center of mass lower in thigh -->
    <!-- Inertial tensor based on cylinder approximation -->
    <inertia ixx="0.12" ixy="0" ixz="0" iyy="0.12" iyz="0" izz="0.02"/>
  </inertial>

  <visual>
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <geometry>
      <mesh filename="package://humanoid_description/meshes/thigh.dae"/>
    </geometry>
    <material name="black"/>
  </visual>

  <collision>
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <geometry>
      <mesh filename="package://humanoid_description/meshes/thigh_collision.stl"/>
    </geometry>
  </collision>
</link>
```

### Joint Definitions for Humanoid Locomotion

Joints connect links and define the degrees of freedom. Humanoid robots require specific joint types for anthropomorphic movement:

```xml
<!-- Hip joints with 3 DOF for humanoid locomotion -->
<joint name="left_hip_yaw_joint" type="revolute">
  <parent link="pelvis"/>
  <child link="left_thigh"/>
  <origin xyz="0.05 0.1 -0.05" rpy="0 0 0"/>  <!-- Offset from pelvis center -->
  <axis xyz="0 0 1"/>  <!-- Yaw motion -->
  <limit lower="-0.52" upper="0.52" effort="300" velocity="5.0"/>  <!-- ±30 degrees -->
  <dynamics damping="1.0" friction="0.1"/>
</joint>

<joint name="left_hip_roll_joint" type="revolute">
  <parent link="left_thigh"/>
  <child link="left_thigh"/>
  <origin xyz="0 0 0" rpy="0 0 0"/>
  <axis xyz="1 0 0"/>  <!-- Roll motion -->
  <limit lower="-0.44" upper="1.57" effort="300" velocity="5.0"/>  <!-- -25 to 90 degrees -->
  <dynamics damping="1.0" friction="0.1"/>
</joint>

<joint name="left_hip_pitch_joint" type="revolute">
  <parent link="left_thigh"/>
  <child link="left_thigh"/>
  <origin xyz="0 0 0" rpy="0 0 0"/>
  <axis xyz="0 1 0"/>  <!-- Pitch motion -->
  <limit lower="-2.09" upper="0.79" effort="300" velocity="5.0"/>  <!-- -120 to 45 degrees -->
  <dynamics damping="1.0" friction="0.1"/>
</joint>

<!-- Knee joint for humanoid leg -->
<joint name="left_knee_joint" type="revolute">
  <parent link="left_thigh"/>
  <child link="left_shin"/>
  <origin xyz="0 0 -0.35" rpy="0 0 0"/>  <!-- Length of thigh -->
  <axis xyz="0 1 0"/>  <!-- Pitch motion -->
  <limit lower="0.0" upper="2.36" effort="300" velocity="5.0"/>  <!-- 0 to 135 degrees -->
  <dynamics damping="1.0" friction="0.1"/>
</joint>

<!-- Ankle joints for balance control -->
<joint name="left_ankle_pitch_joint" type="revolute">
  <parent link="left_shin"/>
  <child link="left_foot"/>
  <origin xyz="0 0 -0.35" rpy="0 0 0"/>  <!-- Length of shin -->
  <axis xyz="0 1 0"/>  <!-- Pitch motion -->
  <limit lower="-0.52" upper="0.52" effort="150" velocity="3.0"/>  <!-- ±30 degrees -->
  <dynamics damping="0.5" friction="0.05"/>
</joint>

<joint name="left_ankle_roll_joint" type="revolute">
  <parent link="left_foot"/>
  <child link="left_foot"/>
  <origin xyz="0 0 0" rpy="0 0 0"/>
  <axis xyz="1 0 0"/>  <!-- Roll motion -->
  <limit lower="-0.35" upper="0.35" effort="150" velocity="3.0"/>  <!-- ±20 degrees -->
  <dynamics damping="0.5" friction="0.05"/>
</joint>
```

## Advanced URDF Features for Humanoid Robots

### Transmission Definitions

Transmission definitions are essential for integrating with ROS 2 control systems:

```xml
<!-- Example transmission for a humanoid joint -->
<transmission name="left_hip_pitch_transmission">
  <type>transmission_interface/SimpleTransmission</type>
  <joint name="left_hip_pitch_joint">
    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
  </joint>
  <actuator name="left_hip_pitch_motor">
    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    <mechanicalReduction>1</mechanicalReduction>
    <motorTorqueConstant>1.0</motorTorqueConstant>
  </actuator>
</transmission>

<!-- For more complex transmissions (harmonic drives, etc.) -->
<transmission name="right_knee_transmission">
  <type>transmission_interface/SimpleTransmission</type>
  <joint name="right_knee_joint">
    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>
  </joint>
  <actuator name="right_knee_actuator">
    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>
    <mechanicalReduction>100</mechanicalReduction>  <!-- Harmonic drive ratio -->
    <motorTorqueConstant>0.05</motorTorqueConstant>
  </actuator>
</transmission>
```

### Gazebo-Specific Elements

For simulation in Gazebo, additional elements are required:

```xml
<!-- Gazebo plugin for ros_control -->
<gazebo>
  <plugin name="gazebo_ros_control" filename="libgazebo_ros2_control.so">
    <parameters>$(find package_name)/config/humanoid_control.yaml</parameters>
    <robotNamespace>/humanoid</robotNamespace>
  </plugin>
</gazebo>

<!-- Gazebo-specific properties for links -->
<gazebo reference="left_foot">
  <mu1>0.8</mu1>  <!-- Friction coefficient -->
  <mu2>0.8</mu2>
  <kp>1000000.0</kp>  <!-- Contact stiffness -->
  <kd>100.0</kd>     <!-- Contact damping -->
  <material>Gazebo/White</material>
  <turnGravityOff>false</turnGravityOff>
</gazebo>

<!-- Gazebo sensors for humanoid perception -->
<gazebo reference="head_camera">
  <sensor type="camera" name="head_camera_sensor">
    <update_rate>30</update_rate>
    <camera name="head_camera">
      <horizontal_fov>1.047</horizontal_fov>
      <image>
        <width>640</width>
        <height>480</height>
        <format>R8G8B8</format>
      </image>
      <clip>
        <near>0.1</near>
        <far>10.0</far>
      </clip>
    </camera>
    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
      <frame_name>head_camera_optical_frame</frame_name>
      <min_depth>0.1</min_depth>
      <max_depth>10.0</max_depth>
    </plugin>
  </sensor>
</gazebo>
```

## Xacro for Humanoid URDF Optimization

Xacro (XML Macros) allows for more maintainable and reusable URDF definitions, especially important for symmetric humanoid components:

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_with_xacro">

  <!-- Properties for humanoid dimensions -->
  <xacro:property name="PI" value="3.1415926535897931"/>
  <xacro:property name="mass_pelvis" value="6.4"/>
  <xacro:property name="mass_thigh" value="5.6"/>
  <xacro:property name="mass_shin" value="4.8"/>
  <xacro:property name="length_thigh" value="0.35"/>
  <xacro:property name="length_shin" value="0.35"/>
  <xacro:property name="hip_offset_y" value="0.12"/>  <!-- Distance from center to hip joint -->

  <!-- Macro for leg definition -->
  <xacro:macro name="humanoid_leg" params="side reflect">
    <!-- Thigh link -->
    <link name="${side}_thigh">
      <inertial>
        <mass value="${mass_thigh}"/>
        <origin xyz="0 0 -${length_thigh/2}" rpy="0 0 0"/>
        <inertia ixx="0.06" ixy="0" ixz="0" iyy="0.06" iyz="0" izz="0.01"/>
      </inertial>

      <visual>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <mesh filename="package://humanoid_description/meshes/thigh.dae"/>
        </geometry>
        <material name="gray"/>
      </visual>

      <collision>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <mesh filename="package://humanoid_description/meshes/thigh_collision.stl"/>
        </geometry>
      </collision>
    </link>

    <!-- Hip joints -->
    <joint name="${side}_hip_yaw_joint" type="revolute">
      <parent link="pelvis"/>
      <child link="${side}_thigh"/>
      <origin xyz="0 ${(reflect)*hip_offset_y} -0.05" rpy="0 0 0"/>
      <axis xyz="0 0 1"/>
      <limit lower="-0.52" upper="0.52" effort="300" velocity="5.0"/>
      <dynamics damping="1.0" friction="0.1"/>
    </joint>

    <joint name="${side}_hip_roll_joint" type="revolute">
      <parent link="${side}_thigh"/>
      <child link="${side}_thigh"/>  <!-- Will be connected to shin in full model -->
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <axis xyz="1 0 0"/>
      <limit lower="-0.44" upper="1.57" effort="300" velocity="5.0"/>
      <dynamics damping="1.0" friction="0.1"/>
    </joint>

    <joint name="${side}_hip_pitch_joint" type="revolute">
      <parent link="${side}_thigh"/>
      <child link="${side}_thigh"/>  <!-- Will be connected to shin in full model -->
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <axis xyz="0 1 0"/>
      <limit lower="-2.09" upper="0.79" effort="300" velocity="5.0"/>
      <dynamics damping="1.0" friction="0.1"/>
    </joint>

    <!-- Shin link -->
    <link name="${side}_shin">
      <inertial>
        <mass value="${mass_shin}"/>
        <origin xyz="0 0 -${length_shin/2}" rpy="0 0 0"/>
        <inertia ixx="0.05" ixy="0" ixz="0" iyy="0.05" iyz="0" izz="0.01"/>
      </inertial>

      <visual>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <mesh filename="package://humanoid_description/meshes/shin.dae"/>
        </geometry>
        <material name="gray"/>
      </visual>

      <collision>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <mesh filename="package://humanoid_description/meshes/shin_collision.stl"/>
        </geometry>
      </collision>
    </link>

    <!-- Knee joint -->
    <joint name="${side}_knee_joint" type="revolute">
      <parent link="${side}_thigh"/>
      <child link="${side}_shin"/>
      <origin xyz="0 0 -${length_thigh}" rpy="0 0 0"/>
      <axis xyz="0 1 0"/>
      <limit lower="0.0" upper="2.36" effort="300" velocity="5.0"/>
      <dynamics damping="1.0" friction="0.1"/>
    </joint>

    <!-- Foot link -->
    <link name="${side}_foot">
      <inertial>
        <mass value="1.5"/>
        <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>
        <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.01"/>
      </inertial>

      <visual>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <mesh filename="package://humanoid_description/meshes/foot.dae"/>
        </geometry>
        <material name="black"/>
      </visual>

      <collision>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <mesh filename="package://humanoid_description/meshes/foot_collision.stl"/>
        </geometry>
      </collision>
    </link>

    <!-- Ankle joints -->
    <joint name="${side}_ankle_pitch_joint" type="revolute">
      <parent link="${side}_shin"/>
      <child link="${side}_foot"/>
      <origin xyz="0 0 -${length_shin}" rpy="0 0 0"/>
      <axis xyz="0 1 0"/>
      <limit lower="-0.52" upper="0.52" effort="150" velocity="3.0"/>
      <dynamics damping="0.5" friction="0.05"/>
    </joint>

    <joint name="${side}_ankle_roll_joint" type="revolute">
      <parent link="${side}_foot"/>
      <child link="${side}_foot"/>  <!-- For full model, would connect to toe -->
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <axis xyz="1 0 0"/>
      <limit lower="-0.35" upper="0.35" effort="150" velocity="3.0"/>
      <dynamics damping="0.5" friction="0.05"/>
    </joint>
  </xacro:macro>

  <!-- Use the macro to create both legs -->
  <xacro:humanoid_leg side="left" reflect="1"/>
  <xacro:humanoid_leg side="right" reflect="-1"/>

</robot>
```

## URDF Validation and Testing

### Validation Tools

Several tools are available to validate URDF models for humanoid robots:

```bash
# Check URDF syntax and structure
check_urdf ~/ros2_ws/src/humanoid_description/urdf/humanoid.urdf

# Parse and visualize the kinematic tree
urdf_to_graphviz ~/ros2_ws/src/humanoid_description/urdf/humanoid.urdf

# Check for self-collisions (though this is computationally intensive for complex humanoid models)
rosrun moveit_ros_planning check_collisions ~/ros2_ws/src/humanoid_description/config/humanoid.srdf
```

### Python Validation Script

For humanoid-specific validation, a custom script can check for common issues:

```python
#!/usr/bin/env python3
# urdf_validator_humanoid.py
import xml.etree.ElementTree as ET
import math
from pathlib import Path

def validate_humanoid_urdf(urdf_path):
    """
    Validate URDF file for humanoid-specific requirements.
    """
    try:
        tree = ET.parse(urdf_path)
        root = tree.getroot()
    except ET.ParseError as e:
        print(f"❌ Invalid XML: {e}")
        return False

    # Check for basic humanoid components
    links = root.findall('.//link')
    joints = root.findall('.//joint')

    print(f"✅ URDF contains {len(links)} links and {len(joints)} joints")

    # Validate mass properties
    total_mass = 0
    for link in links:
        inertial = link.find('inertial')
        if inertial is not None:
            mass_elem = inertial.find('mass')
            if mass_elem is not None:
                try:
                    mass_val = float(mass_elem.get('value'))
                    if mass_val <= 0:
                        print(f"❌ Link {link.get('name')} has non-positive mass: {mass_val}")
                        return False
                    total_mass += mass_val
                except ValueError:
                    print(f"❌ Link {link.get('name')} has invalid mass value")
                    return False

    print(f"✅ Total mass: {total_mass:.2f} kg")

    # Check for humanoid-specific joints
    joint_types = {}
    for joint in joints:
        joint_type = joint.get('type')
        joint_types[joint_type] = joint_types.get(joint_type, 0) + 1

    print(f"✅ Joint types: {joint_types}")

    # Check for bilateral symmetry (basic heuristic)
    left_joints = [j.get('name') for j in joints if 'left' in j.get('name')]
    right_joints = [j.get('name') for j in joints if 'right' in j.get('name')]

    if len(left_joints) > 0 and len(right_joints) > 0:
        print(f"✅ Found bilateral symmetry: {len(left_joints)} left joints, {len(right_joints)} right joints")
    else:
        print("⚠️  No clear bilateral symmetry detected (may be intentional)")

    # Validate joint limits
    invalid_limits = []
    for joint in joints:
        limit = joint.find('limit')
        if limit is not None:
            try:
                lower = float(limit.get('lower', 0))
                upper = float(limit.get('upper', 0))

                # Check for reasonable humanoid joint limits
                if abs(upper - lower) > 10:  # Very wide limits may indicate error
                    print(f"⚠️  Joint {joint.get('name')} has unusually wide limits: {lower} to {upper}")

                if lower > upper:
                    invalid_limits.append(joint.get('name'))

            except ValueError:
                print(f"❌ Joint {joint.get('name')} has invalid limit values")
                return False

    if invalid_limits:
        print(f"❌ Joints with invalid limits: {invalid_limits}")
        return False

    print("✅ All joint limits are valid")

    # Check for proper transforms
    origins = root.findall('.//origin')
    for origin in origins:
        try:
            xyz = origin.get('xyz', '0 0 0').split()
            rpy = origin.get('rpy', '0 0 0').split()

            # Validate that all values are floats
            [float(x) for x in xyz]
            [float(r) for r in rpy]
        except ValueError:
            print(f"❌ Invalid transform values in origin: {origin.attrib}")
            return False

    print("✅ All transforms are valid")

    print("\n✅ URDF validation completed successfully")
    return True

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 urdf_validator_humanoid.py <urdf_file>")
        sys.exit(1)

    urdf_file = sys.argv[1]
    if not Path(urdf_file).exists():
        print(f"❌ URDF file does not exist: {urdf_file}")
        sys.exit(1)

    success = validate_humanoid_urdf(urdf_file)
    sys.exit(0 if success else 1)
```

## Integration with ROS 2 Systems

### Robot State Publisher

The robot_state_publisher node publishes transforms for the robot's kinematic chain:

```python
# robot_state_publisher_launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Declare arguments
    urdf_package = DeclareLaunchArgument(
        'urdf_package',
        default_value='humanoid_description',
        description='Package containing robot description files'
    )

    urdf_file = DeclareLaunchArgument(
        'urdf_file',
        default_value='humanoid.urdf.xacro',
        description='URDF file name'
    )

    # Get URDF path
    urdf_path = PathJoinSubstitution([
        FindPackageShare(LaunchConfiguration('urdf_package')),
        'urdf',
        LaunchConfiguration('urdf_file')
    ])

    # Robot state publisher node
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        parameters=[
            {'robot_description': urdf_path},
            {'use_sim_time': False}
        ],
        output='screen'
    )

    # Joint state publisher (for GUI control during testing)
    joint_state_publisher_gui = Node(
        package='joint_state_publisher_gui',
        executable='joint_state_publisher_gui',
        name='joint_state_publisher_gui',
        condition=launch.conditions.IfCondition(LaunchConfiguration('use_gui'))
    )

    return LaunchDescription([
        urdf_package,
        urdf_file,
        robot_state_publisher,
        joint_state_publisher_gui
    ])
```

### TF Transform Validation

For humanoid robots, proper TF transforms are critical for balance control and perception:

```bash
# Check TF tree for humanoid robot
ros2 run tf2_tools view_frames

# Echo specific transforms
ros2 run tf2_ros tf2_echo base_link left_foot

# Monitor TF publishing rate
ros2 run tf2_ros tf2_monitor base_link left_foot
```

## Performance Optimization for Humanoid URDF

### Mesh Optimization

For humanoid robots with many links, mesh optimization is important:

1. **Visual Meshes**: High-detail for visualization, low-poly for collision
2. **Collision Meshes**: Convex hulls or primitive shapes for performance
3. **Level of Detail**: Different meshes for different distances

### Inertial Property Optimization

Proper inertial properties are critical for humanoid balance:

```xml
<!-- Properly calculated inertial properties for humanoid links -->
<xacro:macro name="humanoid_link_with_inertia" params="name mass length width height">
  <link name="${name}">
    <inertial>
      <mass value="${mass}"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <!-- Approximate inertia for box-shaped link -->
      <inertia
        ixx="${mass*(width*width + height*height)/12}"
        ixy="0"
        ixz="0"
        iyy="${mass*(length*length + height*height)/12}"
        iyz="0"
        izz="${mass*(length*length + width*width)/12}"/>
    </inertial>

    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="package://humanoid_description/meshes/${name}.dae"/>
      </geometry>
    </visual>

    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="package://humanoid_description/meshes/${name}_collision.stl"/>
      </geometry>
    </collision>
  </link>
</xacro:macro>
```

## Troubleshooting Common URDF Issues

### Kinematic Chain Issues

**Problem**: Invalid kinematic chain (multiple roots, disconnected links)
**Solution**: Ensure single base link with tree structure to all other links

```xml
<!-- Ensure all links are connected to the kinematic tree -->
<joint name="proper_connection" type="fixed">
  <parent link="existing_link"/>
  <child link="new_link"/>
  <origin xyz="0 0 0" rpy="0 0 0"/>
</joint>
```

### Inertial Issues

**Problem**: Simulation instability due to improper inertial properties
**Solution**: Use proper mass distribution and realistic inertial tensors

### Joint Limit Issues

**Problem**: Joint limits that don't match hardware capabilities
**Solution**: Verify limits match actual humanoid robot specifications

## Best Practices for Humanoid URDF

1. **Modular Design**: Use xacro macros for repetitive components
2. **Realistic Properties**: Base masses and inertias on actual humanoid hardware
3. **Performance**: Optimize meshes for real-time simulation
4. **Validation**: Regularly validate URDF with `check_urdf`
5. **Documentation**: Comment URDF files with rationale for values
6. **Version Control**: Track changes to URDF files carefully
7. **Testing**: Test URDF in simulation before real hardware deployment

## Summary

This chapter has covered the essential aspects of creating URDF models for humanoid robots. Proper URDF modeling is fundamental to successful humanoid robotics development, affecting simulation accuracy, control performance, and perception capabilities. The complex kinematic structure of humanoid robots requires careful attention to joint definitions, inertial properties, and geometric representations.

Key takeaways for humanoid URDF development include:
- Use xacro macros to manage repetitive structures and maintain symmetry
- Carefully validate inertial properties for balance control
- Optimize meshes for simulation performance while maintaining accuracy
- Ensure proper TF transforms for perception and control systems
- Test URDF models thoroughly before deployment

Understanding these concepts is essential for the subsequent modules, particularly when integrating with simulation environments and developing advanced control algorithms for humanoid robots.

## References

Quigley, M., Gerkey, B., & Smart, W. D. (2009). ROS: An open-source Robot Operating System. *ICRA Workshop on Open Source Software*, 3(3.2), 5.

Siciliano, B., & Khatib, O. (2016). *Springer Handbook of Robotics* (2nd ed.). Springer.

Corrales, J. A., Candelas, F. A., & Torres, F. (2016). Solutions for the generation and the simulation of a realistic human-like robotic arm. *Robotica*, 34(1), 188-207.

Mistry, M., & Schaal, S. (2009). Humanoid ocsillator-driven walking control. *IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*, 4650-4655.

Bohg, J., Kragic, D., & Mistry, M. (2010). Grasp recognition and mapping through task-relevant grasp features. *IEEE Transactions on Robotics*, 26(1), 17-27.