---
title: "Chapter 4: Advanced ROS 2 Topics for Humanoid Robotics"
description: "Advanced ROS 2 concepts including lifecycle nodes, parameters, actions, and real-time considerations for humanoid robots"
estimated_time: 6
week: 5
module: "Module 1: ROS 2 Fundamentals"
prerequisites:
  - "intro"
  - "module-1-ros2/index"
  - "module-1-ros2/chapter1"
  - "module-1-ros2/chapter2"
  - "module-1-ros2/chapter3"
learning_objectives:
  - "Implement lifecycle nodes for humanoid robot management with proper state transitions"
  - "Design parameter systems for configurable humanoid robot behavior with validation"
  - "Create action servers for complex humanoid robot tasks with feedback and cancellation"
  - "Apply real-time considerations and performance optimization for humanoid control"
  - "Integrate advanced ROS 2 concepts into comprehensive humanoid robot systems"
sidebar_label: "Advanced Topics"
difficulty: "Advanced"
tags:
  - "ros2"
  - "lifecycle"
  - "parameters"
  - "actions"
  - "real-time"
  - "humanoid-robotics"
  - "performance"
code_examples:
  total: 8
  languages:
    - "python"
    - "bash"
    - "yaml"
    - "xml"
related_chapters:
  - "module-1-ros2/chapter1"
  - "module-1-ros2/chapter2"
  - "module-1-ros2/chapter3"
  - "module-1-ros2/chapter5"
  - "module-3-isaac/chapter2"
appendix_references:
  - "appendix-a"
  - "appendix-b"
glossary_terms:
  - "lifecycle-node"
  - "action"
  - "parameter"
  - "real-time"
  - "quality-of-service"
  - "ros2-control"
---

# Chapter 4: Advanced ROS 2 Topics for Humanoid Robotics

## Introduction to Advanced ROS 2 Concepts

This chapter explores advanced ROS 2 concepts that are essential for developing sophisticated humanoid robot systems. While basic topics like nodes, topics, and services form the foundation of ROS 2 communication, advanced features such as lifecycle nodes, parameters, and actions are crucial for building robust, configurable, and mission-critical humanoid robotics applications.

Advanced ROS 2 features provide the tools necessary for creating production-ready humanoid systems that can handle complex state management, real-time constraints, and dynamic reconfiguration. Research by Paredis et al. (2017) demonstrates that advanced ROS 2 concepts are essential for developing reliable robotics systems, with lifecycle management and parameter systems providing critical infrastructure for safety-critical applications.

For humanoid robotics specifically, these advanced concepts address unique challenges:

- **Safety Requirements**: Lifecycle nodes enable controlled state transitions for safe operation
- **Dynamic Configuration**: Parameter systems allow runtime adjustment of control gains and behaviors
- **Long-Running Tasks**: Actions provide feedback and cancellation for complex humanoid maneuvers
- **Real-time Performance**: Advanced QoS settings ensure deterministic behavior for humanoid control

## Lifecycle Nodes for Humanoid Robotics

### Understanding Lifecycle Nodes

Lifecycle nodes provide a structured approach to node state management, which is particularly important for humanoid robotics where safety and predictable behavior are paramount. Unlike regular nodes that transition directly from creation to execution, lifecycle nodes follow a well-defined state machine that ensures proper initialization, configuration, and shutdown.

The lifecycle state machine includes:
1. **Unconfigured**: Node created but not yet configured
2. **Inactive**: Configured but not active
3. **Active**: Running and operational
4. **Finalized**: Node is shutting down

For humanoid robots, this structured approach is essential for safety-critical operations where proper initialization and cleanup procedures must be followed to prevent damage or injury.

### Implementing Lifecycle Nodes

Here's an example of a lifecycle node for humanoid robot control:

```python
# humanoid_lifecycle_controller.py
import rclpy
from rclpy.lifecycle import LifecycleNode, LifecycleState, TransitionCallbackReturn
from rclpy.qos import QoSProfile, QoSHistoryPolicy, QoSReliabilityPolicy
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Twist
from std_msgs.msg import Bool
from builtin_interfaces.msg import Time
import time

class HumanoidLifecycleController(LifecycleNode):
    """
    A lifecycle node for humanoid robot control with safety-critical state management.
    This implementation demonstrates proper lifecycle management for humanoid applications.
    """

    def __init__(self):
        super().__init__('humanoid_lifecycle_controller')

        # Initialize internal state
        self.joint_positions = {}
        self.joint_velocities = {}
        self.desired_velocity = Twist()
        self.is_operational = False
        self.emergency_stop_active = False

        # These will be initialized during the lifecycle
        self.joint_command_publisher = None
        self.status_publisher = None
        self.joint_state_subscriber = None
        self.velocity_subscriber = None
        self.emergency_stop_subscriber = None
        self.control_timer = None

        self.get_logger().info('Humanoid lifecycle controller initialized (unconfigured)')

    def on_configure(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Configure the node - create publishers, subscribers, services, and parameters.
        This is called when transitioning from unconfigured to inactive state.
        """
        self.get_logger().info('Configuring humanoid controller')

        # Create publishers with appropriate QoS for humanoid control
        self.joint_command_publisher = self.create_publisher(
            JointState,
            'joint_commands',
            QoSProfile(
                history=QoSHistoryPolicy.RMW_QOS_HISTORY_POLICY_KEEP_LAST,
                depth=1,
                reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE
            )
        )

        self.status_publisher = self.create_publisher(
            Bool,
            'controller_status',
            10
        )

        # Create subscribers
        self.joint_state_subscriber = self.create_subscription(
            JointState,
            'joint_states',
            self.joint_state_callback,
            QoSProfile(
                history=QoSHistoryPolicy.RMW_QOS_HISTORY_POLICY_KEEP_LAST,
                depth=10,
                reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE
            )
        )

        self.velocity_subscriber = self.create_subscription(
            Twist,
            'cmd_vel',
            self.velocity_command_callback,
            10
        )

        self.emergency_stop_subscriber = self.create_subscription(
            Bool,
            'emergency_stop',
            self.emergency_stop_callback,
            1
        )

        # Declare parameters for dynamic reconfiguration
        self.declare_parameter('control_frequency', 100, rclpy.Parameter.Type.INTEGER)
        self.declare_parameter('max_joint_velocity', 5.0, rclpy.Parameter.Type.DOUBLE)
        self.declare_parameter('balance_threshold', 0.05, rclpy.Parameter.Type.DOUBLE)

        # Get parameter values
        self.control_frequency = self.get_parameter('control_frequency').value
        self.max_joint_velocity = self.get_parameter('max_joint_velocity').value
        self.balance_threshold = self.get_parameter('balance_threshold').value

        # Validate parameters
        if self.control_frequency <= 0 or self.control_frequency > 1000:
            self.get_logger().error(f'Invalid control frequency: {self.control_frequency}')
            return TransitionCallbackReturn.FAILURE

        if self.max_joint_velocity <= 0:
            self.get_logger().error(f'Invalid max_joint_velocity: {self.max_joint_velocity}')
            return TransitionCallbackReturn.FAILURE

        self.get_logger().info(
            f'Configuration complete: {self.control_frequency}Hz, '
            f'max velocity: {self.max_joint_velocity} rad/s'
        )

        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Activate the node - enable publishers/subscribers and start timers.
        This is called when transitioning from inactive to active state.
        """
        self.get_logger().info('Activating humanoid controller')

        # Activate publishers
        self.joint_command_publisher.on_activate()
        self.status_publisher.on_activate()

        # Start control timer
        self.control_timer = self.create_timer(
            1.0 / self.control_frequency,
            self.control_loop
        )

        # Set operational flag
        self.is_operational = True

        # Publish activation status
        status_msg = Bool()
        status_msg.data = True
        self.status_publisher.publish(status_msg)

        self.get_logger().info('Humanoid controller activated successfully')
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Deactivate the node - stop timers and deactivate publishers.
        This is called when transitioning from active to inactive state.
        """
        self.get_logger().info('Deactivating humanoid controller')

        # Stop control timer
        if self.control_timer:
            self.control_timer.destroy()

        # Deactivate publishers
        self.joint_command_publisher.on_deactivate()
        self.status_publisher.on_deactivate()

        # Clear operational flag
        self.is_operational = False

        # Publish deactivation status
        status_msg = Bool()
        status_msg.data = False
        self.status_publisher.publish(status_msg)

        self.get_logger().info('Humanoid controller deactivated successfully')
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Clean up resources allocated during configuration.
        This is called when transitioning from inactive to unconfigured state.
        """
        self.get_logger().info('Cleaning up humanoid controller resources')

        # Destroy subscribers
        if self.joint_state_subscriber:
            self.destroy_subscription(self.joint_state_subscriber)
        if self.velocity_subscriber:
            self.destroy_subscription(self.velocity_subscriber)
        if self.emergency_stop_subscriber:
            self.destroy_subscription(self.emergency_stop_subscriber)

        # Destroy publishers
        if self.joint_command_publisher:
            self.destroy_publisher(self.joint_command_publisher)
        if self.status_publisher:
            self.destroy_publisher(self.status_publisher)

        # Reset state
        self.joint_positions = {}
        self.desired_velocity = Twist()
        self.emergency_stop_active = False

        self.get_logger().info('Humanoid controller cleaned up successfully')
        return TransitionCallbackReturn.SUCCESS

    def on_shutdown(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Shutdown the node - final cleanup before node destruction.
        This is called when transitioning to finalized state.
        """
        self.get_logger().info('Shutting down humanoid controller')

        # Perform final safety procedures
        self.publish_zero_commands()

        return TransitionCallbackReturn.SUCCESS

    def on_error(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Handle errors during lifecycle transitions.
        """
        self.get_logger().error(f'Error occurred in state: {state.label}')
        return TransitionCallbackReturn.SUCCESS

    def joint_state_callback(self, msg):
        """
        Handle joint state messages during active operation.
        """
        if not self.is_operational:
            return

        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.joint_positions[name] = msg.position[i]
            if i < len(msg.velocity):
                self.joint_velocities[name] = msg.velocity[i]

    def velocity_command_callback(self, msg):
        """
        Handle velocity commands during active operation.
        """
        if not self.is_operational:
            return

        self.desired_velocity = msg

    def emergency_stop_callback(self, msg):
        """
        Handle emergency stop commands.
        """
        self.emergency_stop_active = msg.data
        if self.emergency_stop_active:
            self.get_logger().fatal('EMERGENCY STOP ACTIVATED')
            self.publish_zero_commands()

    def control_loop(self):
        """
        Main control loop executed when node is active.
        """
        if not self.is_operational or self.emergency_stop_active:
            return

        # Implement advanced humanoid control logic here
        # This is a simplified example - real implementation would be more complex
        self.execute_advanced_control()

        # Publish safety status
        status_msg = Bool()
        status_msg.data = not self.emergency_stop_active
        self.status_publisher.publish(status_msg)

    def execute_advanced_control(self):
        """
        Execute advanced control algorithms for humanoid robot.
        """
        # Advanced control logic would go here
        # This could include:
        # - Balance control algorithms (ZMP-based or LIPM)
        # - Trajectory generation and execution
        # - Sensor fusion for state estimation
        # - Adaptive control based on environmental conditions
        pass

    def publish_zero_commands(self):
        """
        Publish zero commands to all joints for safety.
        """
        if self.joint_command_publisher:
            zero_cmd = JointState()
            zero_cmd.name = list(self.joint_positions.keys())
            zero_cmd.position = [0.0] * len(zero_cmd.name)
            zero_cmd.velocity = [0.0] * len(zero_cmd.name)
            zero_cmd.effort = [0.0] * len(zero_cmd.name)
            zero_cmd.header.stamp = self.get_clock().now().to_msg()

            self.joint_command_publisher.publish(zero_cmd)
            self.get_logger().info('Zero commands published for safety')

def main(args=None):
    rclpy.init(args=args)

    node = HumanoidLifecycleController()

    # Example of transitioning through lifecycle states
    # In a real application, these transitions would be triggered by services or external commands
    node.trigger_configure()
    node.trigger_activate()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Interrupted, initiating shutdown sequence')
    finally:
        # Properly transition through lifecycle states
        if node.lifecycle_state.label == 'active':
            node.trigger_deactivate()
        if node.lifecycle_state.label == 'inactive':
            node.trigger_cleanup()
        if node.lifecycle_state.label != 'finalized':
            node.trigger_shutdown()

        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Lifecycle Management for Safety-Critical Operations

For humanoid robots, lifecycle management is particularly important for safety-critical operations:

```python
# safety_lifecycle_manager.py
import rclpy
from rclpy.lifecycle import LifecycleNode, LifecycleState, TransitionCallbackReturn
from rclpy.executors import MultiThreadedExecutor
from std_msgs.msg import Bool
from sensor_msgs.msg import JointState
import threading
from enum import Enum

class HumanoidSafetyState(Enum):
    """Safety states for humanoid robot lifecycle management."""
    INITIALIZING = 0
    SAFETY_CHECK_PASS = 1
    READY_TO_OPERATE = 2
    OPERATIONAL = 3
    EMERGENCY_STOP = 4
    MAINTENANCE_MODE = 5

class HumanoidSafetyManager(LifecycleNode):
    """
    Safety manager for humanoid robot lifecycle with safety-critical state transitions.
    """

    def __init__(self):
        super().__init__('humanoid_safety_manager')

        self.safety_state = HumanoidSafetyState.INITIALIZING
        self.joint_states = {}
        self.safety_checks_passed = False

        # Components to be initialized during lifecycle
        self.safety_publisher = None
        self.emergency_stop_subscriber = None
        self.joint_state_subscriber = None
        self.safety_monitor_timer = None

        self.get_logger().info('Humanoid safety manager initialized (unconfigured)')

    def on_configure(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Configure safety systems and perform initial safety checks.
        """
        self.get_logger().info('Configuring safety systems')

        # Create safety publishers and subscribers
        self.safety_publisher = self.create_publisher(Bool, 'safety_status', 10)
        self.emergency_stop_subscriber = self.create_subscription(
            Bool, 'emergency_stop', self.emergency_stop_callback, 1
        )
        self.joint_state_subscriber = self.create_subscription(
            JointState, 'joint_states', self.joint_state_callback, 10
        )

        # Perform initial safety checks
        self.safety_checks_passed = self.perform_initial_safety_checks()

        if self.safety_checks_passed:
            self.safety_state = HumanoidSafetyState.SAFETY_CHECK_PASS
            self.get_logger().info('Safety checks passed, ready for activation')
            return TransitionCallbackReturn.SUCCESS
        else:
            self.get_logger().error('Safety checks failed, cannot proceed to active state')
            return TransitionCallbackReturn.FAILURE

    def on_activate(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Activate safety monitoring systems.
        """
        self.get_logger().info('Activating safety monitoring')

        # Activate publishers
        self.safety_publisher.on_activate()

        # Start safety monitoring timer
        self.safety_monitor_timer = self.create_timer(0.1, self.safety_monitor)  # 10Hz safety checks

        self.safety_state = HumanoidSafetyState.READY_TO_OPERATE
        self.get_logger().info('Safety systems activated')

        return TransitionCallbackReturn.SUCCESS

    def perform_initial_safety_checks(self):
        """
        Perform comprehensive safety checks before activation.
        """
        checks = []

        # Check for critical joint availability
        critical_joints = [
            'left_hip_pitch', 'right_hip_pitch',
            'left_knee', 'right_knee',
            'left_ankle_pitch', 'right_ankle_pitch'
        ]

        # Note: We can't check joint availability until we receive joint states
        # So we'll return True initially and perform checks in the monitoring loop
        return True

    def safety_monitor(self):
        """
        Continuous safety monitoring during operation.
        """
        if self.safety_state == HumanoidSafetyState.OPERATIONAL:
            # Perform real-time safety checks
            if not self.real_time_safety_check():
                self.initiate_safety_procedure()

    def real_time_safety_check(self):
        """
        Perform real-time safety checks on joint positions, velocities, and other parameters.
        """
        # Check joint limits
        for joint_name, position in self.joint_states.items():
            # Example: Check for extreme joint positions
            if abs(position) > 5.0:  # Unreasonable joint position
                self.get_logger().error(f'Joint limit violation for {joint_name}: {position}')
                return False

            # Check for excessive velocities (if velocity information is available)
            # This would require checking joint velocity data when available

        # Check for reasonable joint state age
        # This would require tracking timestamps when joint states are received

        return True

    def initiate_safety_procedure(self):
        """
        Initiate safety procedures when safety checks fail.
        """
        self.get_logger().fatal('SAFETY CHECK FAILED - INITIATING EMERGENCY PROCEDURES')

        # Change safety state
        self.safety_state = HumanoidSafetyState.EMERGENCY_STOP

        # Publish emergency stop
        emergency_msg = Bool()
        emergency_msg.data = True
        self.safety_publisher.publish(emergency_msg)

        # Send zero commands to all joints
        self.publish_zero_commands()

    def emergency_stop_callback(self, msg):
        """
        Handle emergency stop commands from external sources.
        """
        if msg.data:
            self.safety_state = HumanoidSafetyState.EMERGENCY_STOP
            self.get_logger().fatal('EXTERNAL EMERGENCY STOP RECEIVED')

            # Send zero commands to all joints
            self.publish_zero_commands()
        else:
            if self.safety_state == HumanoidSafetyState.EMERGENCY_STOP:
                self.safety_state = HumanoidSafetyState.SAFETY_CHECK_PASS
                self.get_logger().info('Emergency stop cleared, safety checks passed')

    def joint_state_callback(self, msg):
        """
        Update joint state information for safety monitoring.
        """
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.joint_states[name] = msg.position[i]

    def publish_zero_commands(self):
        """
        Publish zero commands to stop all joints for safety.
        """
        # This would publish zero commands to all joints in a real implementation
        pass

def main(args=None):
    rclpy.init(args=args)

    node = HumanoidSafetyManager()

    # Configure and activate the safety manager
    node.trigger_configure()
    node.trigger_activate()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Shutting down safety manager')
    finally:
        # Properly shut down lifecycle node
        if node.lifecycle_state.label == 'active':
            node.trigger_deactivate()
        if node.lifecycle_state.label == 'inactive':
            node.trigger_cleanup()
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Parameter Systems for Humanoid Robotics

### Advanced Parameter Management

Parameters in ROS 2 allow for dynamic configuration of nodes at runtime, which is particularly valuable for humanoid robotics where control parameters often need adjustment based on different conditions or user preferences:

```python
# humanoid_parameter_controller.py
import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from rclpy.qos import QoSProfile
from sensor_msgs.msg import JointState, Imu
from geometry_msgs.msg import Twist
from std_msgs.msg import Float64
import numpy as np
from typing import Dict, List, Any

class HumanoidParameterController(Node):
    """
    Advanced parameter controller for humanoid robots with dynamic reconfiguration.
    Demonstrates complex parameter management for humanoid control systems.
    """

    def __init__(self):
        super().__init__('humanoid_parameter_controller')

        # Declare complex parameters including arrays and dictionaries
        self.declare_parameter('robot_name', 'unitree_g1')
        self.declare_parameter('control_mode', 'position')
        self.declare_parameter('control_frequency', 100)
        self.declare_parameter('logging_enabled', True)

        # Joint-specific parameters (example for a few joints)
        self.declare_parameter('joint_gains.left_hip_pitch.p_gain', 100.0)
        self.declare_parameter('joint_gains.left_hip_pitch.i_gain', 10.0)
        self.declare_parameter('joint_gains.left_hip_pitch.d_gain', 50.0)

        self.declare_parameter('joint_gains.right_hip_pitch.p_gain', 100.0)
        self.declare_parameter('joint_gains.right_hip_pitch.i_gain', 10.0)
        self.declare_parameter('joint_gains.right_hip_pitch.d_gain', 50.0)

        # Balance control parameters
        self.declare_parameter('balance_control.enable', True)
        self.declare_parameter('balance_control.p_gain', 50.0)
        self.declare_parameter('balance_control.d_gain', 10.0)
        self.declare_parameter('balance_control.zmp_tolerance', 0.05)

        # Walking gait parameters
        self.declare_parameter('walking.stride_length', 0.3)
        self.declare_parameter('walking.step_height', 0.05)
        self.declare_parameter('walking.step_duration', 0.8)
        self.declare_parameter('walking.enable_autostepping', True)

        # Safety parameters
        self.declare_parameter('safety.max_joint_velocity', 5.0)
        self.declare_parameter('safety.max_joint_torque', 300.0)
        self.declare_parameter('safety.balance_threshold', 0.1)
        self.declare_parameter('safety.emergency_stop_timeout', 1.0)

        # Initialize parameter cache
        self.param_cache = {}
        self.update_parameter_cache()

        # Set up parameter callback for dynamic changes
        self.add_on_set_parameters_callback(self.parameter_change_callback)

        # Create publishers and subscribers
        self.joint_command_publisher = self.create_publisher(
            JointState, 'joint_commands', QoSProfile(depth=10)
        )
        self.joint_state_subscriber = self.create_subscription(
            JointState, 'joint_states', self.joint_state_callback, 10
        )
        self.imu_subscriber = self.create_subscription(
            Imu, 'imu/data', self.imu_callback, 10
        )

        # Control timer
        self.control_timer = self.create_timer(
            1.0 / self.get_parameter('control_frequency').value,
            self.control_loop
        )

        # Initialize state
        self.current_joint_positions = {}
        self.current_joint_velocities = {}
        self.imu_data = None
        self.last_parameter_update = self.get_clock().now()

        self.get_logger().info('Humanoid parameter controller initialized')

    def update_parameter_cache(self):
        """
        Update local cache of parameter values for fast access during control.
        """
        self.param_cache['control_frequency'] = self.get_parameter('control_frequency').value
        self.param_cache['logging_enabled'] = self.get_parameter('logging_enabled').value
        self.param_cache['max_joint_velocity'] = self.get_parameter('safety.max_joint_velocity').value
        self.param_cache['max_joint_torque'] = self.get_parameter('safety.max_joint_torque').value
        self.param_cache['balance_threshold'] = self.get_parameter('safety.balance_threshold').value
        self.param_cache['balance_enabled'] = self.get_parameter('balance_control.enable').value
        self.param_cache['balance_p_gain'] = self.get_parameter('balance_control.p_gain').value
        self.param_cache['balance_d_gain'] = self.get_parameter('balance_control.d_gain').value
        self.param_cache['zmp_tolerance'] = self.get_parameter('balance_control.zmp_tolerance').value
        self.param_cache['stride_length'] = self.get_parameter('walking.stride_length').value
        self.param_cache['step_height'] = self.get_parameter('walking.step_height').value
        self.param_cache['step_duration'] = self.get_parameter('walking.step_duration').value

    def parameter_change_callback(self, parameters):
        """
        Callback for parameter changes during runtime.
        """
        result = rclpy.parameter.SetParametersResult()
        result.successful = True
        result.reason = 'Parameters set successfully'

        updated_params = []

        for param in parameters:
            # Validate parameter changes based on safety constraints
            if param.name.startswith('safety.'):
                if not self.validate_safety_parameter(param):
                    result.successful = False
                    result.reason = f'Safety parameter validation failed: {param.name}'
                    return result

            # Update local cache for frequently accessed parameters
            if param.name in [
                'control_frequency', 'logging_enabled', 'safety.max_joint_velocity',
                'safety.max_joint_torque', 'safety.balance_threshold', 'balance_control.enable',
                'balance_control.p_gain', 'balance_control.d_gain', 'balance_control.zmp_tolerance',
                'walking.stride_length', 'walking.step_height', 'walking.step_duration'
            ]:
                param_path = param.name.split('.')
                if len(param_path) > 1:
                    self.param_cache[param_path[-1]] = param.value
                else:
                    self.param_cache[param.name] = param.value
                updated_params.append(param.name)

        if updated_params and self.param_cache.get('logging_enabled', True):
            self.get_logger().info(f'Parameters updated: {updated_params}')

        # If control frequency changed, adjust timer
        if 'control_frequency' in [p.name for p in parameters]:
            new_freq = self.get_parameter('control_frequency').value
            if new_freq > 0:
                self.control_timer.timer_period_ns = int(1e9 / new_freq)
                self.get_logger().info(f'Control frequency adjusted to {new_freq}Hz')

        return result

    def validate_safety_parameter(self, param: Parameter):
        """
        Validate safety-critical parameters to prevent unsafe configurations.
        """
        if param.name == 'safety.max_joint_velocity':
            if param.value <= 0 or param.value > 50.0:  # Reasonable limit for humanoid joints
                self.get_logger().error(f'Invalid max_joint_velocity: {param.value}')
                return False
        elif param.name == 'safety.max_joint_torque':
            if param.value <= 0 or param.value > 1000.0:  # Reasonable limit for humanoid actuators
                self.get_logger().error(f'Invalid max_joint_torque: {param.value}')
                return False
        elif param.name == 'safety.balance_threshold':
            if param.value <= 0 or param.value > 1.0:  # Reasonable balance threshold
                self.get_logger().error(f'Invalid balance_threshold: {param.value}')
                return False
        elif param.name == 'safety.emergency_stop_timeout':
            if param.value <= 0 or param.value > 5.0:  # Reasonable timeout range
                self.get_logger().error(f'Invalid emergency_stop_timeout: {param.value}')
                return False

        return True

    def joint_state_callback(self, msg):
        """
        Update joint state information for control.
        """
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.current_joint_positions[name] = msg.position[i]
            if i < len(msg.velocity):
                self.current_joint_velocities[name] = msg.velocity[i]

    def imu_callback(self, msg):
        """
        Update IMU data for balance control.
        """
        self.imu_data = msg

    def control_loop(self):
        """
        Main control loop that uses parameterized values.
        """
        if not self.current_joint_positions:
            return  # Wait for joint data

        # Get current parameter values from cache
        balance_enabled = self.param_cache.get('balance_enabled', True)
        stride_length = self.param_cache.get('stride_length', 0.3)

        # Execute control based on current parameters
        if balance_enabled:
            self.execute_balance_control()

        # Check for walking commands and execute if parameters allow
        if self.should_execute_walking():
            self.execute_walking_pattern(stride_length)

        # Validate joint velocities against safety limits
        self.enforce_velocity_limits()

        # Publish commands if safety checks pass
        self.publish_control_commands()

    def execute_balance_control(self):
        """
        Execute balance control using parameterized gains.
        """
        if not self.imu_data:
            return

        # Use parameterized gains for balance control
        p_gain = self.param_cache.get('balance_p_gain', 50.0)
        d_gain = self.param_cache.get('balance_d_gain', 10.0)
        tolerance = self.param_cache.get('zmp_tolerance', 0.05)

        # Calculate balance error from IMU data
        # (Simplified example - real implementation would be more complex)
        balance_error = self.calculate_balance_error_from_imu()

        # Apply parameterized control law
        control_output = p_gain * balance_error + d_gain * 0  # Simplified derivative = 0

        if abs(balance_error) > tolerance:
            self.get_logger().debug(f'Balance adjustment needed: error={balance_error:.3f}, control={control_output:.3f}')

    def calculate_balance_error_from_imu(self):
        """
        Calculate balance error from IMU data (simplified).
        """
        if not self.imu_data:
            return 0.0

        # Extract orientation from IMU quaternion
        q = self.imu_data.orientation
        # Simplified balance error calculation based on roll/pitch angles
        # Real implementation would use ZMP or capture point calculations
        roll = np.arctan2(2*(q.w*q.x + q.y*q.z), 1 - 2*(q.x*q.x + q.y*q.y))
        pitch = np.arcsin(2*(q.w*q.y - q.z*q.x))

        # Combine roll and pitch for balance error
        return np.sqrt(roll*roll + pitch*pitch)

    def should_execute_walking(self):
        """
        Check if walking should be executed based on parameters and safety.
        """
        # This would check for walking commands and parameter-enabled conditions
        return True  # Simplified for example

    def execute_walking_pattern(self, stride_length):
        """
        Execute walking pattern based on parameterized stride length.
        """
        # Walking pattern generation using parameterized values
        pass

    def enforce_velocity_limits(self):
        """
        Enforce velocity limits based on parameterized safety values.
        """
        max_velocity = self.param_cache.get('max_joint_velocity', 5.0)

        for joint_name, velocity in self.current_joint_velocities.items():
            if abs(velocity) > max_velocity:
                clamped_velocity = np.sign(velocity) * max_velocity
                self.get_logger().warn(
                    f'Clamping velocity for {joint_name}: {velocity:.2f} -> {clamped_velocity:.2f}'
                )
                self.current_joint_velocities[joint_name] = clamped_velocity

    def publish_control_commands(self):
        """
        Publish control commands based on current control state.
        """
        # This would publish joint commands based on current control state
        pass

def main(args=None):
    rclpy.init(args=args)

    node = HumanoidParameterController()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Shutting down parameter controller')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Actions for Complex Humanoid Tasks

### Understanding Actions in Humanoid Robotics

Actions in ROS 2 are designed for long-running tasks that require feedback and the ability to cancel. For humanoid robots, actions are particularly important for complex behaviors such as:

- Walking to a location
- Manipulating objects
- Performing calibration routines
- Executing complex behaviors or dances
- Running multi-step tasks with intermediate feedback

Unlike services, which are synchronous and block until completion, actions allow for asynchronous execution with continuous feedback and cancellation capabilities.

### Implementing Action Servers

Here's an example of an action server for humanoid walking:

```python
# humanoid_walking_action.py
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from rclpy.qos import QoSProfile
from humanoid_msgs.action import WalkToGoal  # Custom action message
from sensor_msgs.msg import JointState, Imu
from geometry_msgs.msg import Pose, Point
from std_msgs.msg import Bool
import time
import math
from enum import Enum

class WalkingState(Enum):
    """State machine for walking action."""
    IDLE = 0
    INITIALIZING = 1
    PLANNING_PATH = 2
    EXECUTING_STEP = 3
    BALANCING = 4
    COMPLETING = 5
    CANCELLED = 6
    ABORTED = 7

class HumanoidWalkingActionServer(Node):
    """
    Action server for humanoid walking tasks with feedback and cancellation.
    """

    def __init__(self):
        super().__init__('humanoid_walking_action_server')

        # Create action server
        self._action_server = ActionServer(
            self,
            WalkToGoal,
            'walk_to_goal',
            execute_callback=self.execute_callback,
            callback_group=None,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback
        )

        # Create subscribers for sensor data
        self.joint_state_subscriber = self.create_subscription(
            JointState, 'joint_states', self.joint_state_callback, 10
        )
        self.imu_subscriber = self.create_subscription(
            Imu, 'imu/data', self.imu_callback, 10
        )

        # Create publishers for commands
        self.joint_command_publisher = self.create_publisher(
            JointState, 'joint_commands', QoSProfile(depth=10)
        )
        self.status_publisher = self.create_publisher(Bool, 'walking_status', 10)

        # Initialize state
        self.current_joint_positions = {}
        self.current_joint_velocities = {}
        self.imu_data = None
        self.is_walking = False
        self.current_state = WalkingState.IDLE

        self.get_logger().info('Humanoid walking action server initialized')

    def destroy_node(self):
        """Clean up action server when node is destroyed."""
        self._action_server.destroy()
        super().destroy_node()

    def goal_callback(self, goal_request):
        """
        Called when a new goal is requested.
        """
        self.get_logger().info(
            f'Received walk goal: ({goal_request.target_pose.position.x:.2f}, '
            f'{goal_request.target_pose.position.y:.2f}, {goal_request.target_pose.position.z:.2f})'
        )

        # Validate goal request
        if self.is_walking:
            self.get_logger().warn('Already executing a walking task, rejecting new goal')
            return GoalResponse.REJECT

        # Check if goal is reachable
        if not self.is_goal_reachable(goal_request.target_pose):
            self.get_logger().warn('Goal is not reachable')
            return GoalResponse.REJECT

        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """
        Called when a goal receives a cancel request.
        """
        self.get_logger().info('Received cancel request for walking goal')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """
        Execute the walking goal with feedback and cancellation support.
        """
        self.get_logger().info('Executing walking goal')

        # Set walking flag
        self.is_walking = True
        self.current_state = WalkingState.INITIALIZING

        # Get goal parameters
        target_pose = goal_handle.request.target_pose
        walk_speed = goal_handle.request.speed
        step_height = goal_handle.request.step_height

        # Initialize feedback message
        feedback_msg = WalkToGoal.Feedback()
        result = WalkToGoal.Result()

        # Check for safety before starting
        if not self.pre_walk_safety_check():
            goal_handle.abort()
            result.success = False
            result.message = 'Safety check failed, cannot start walking'
            self.is_walking = False
            return result

        # Calculate path to target
        self.current_state = WalkingState.PLANNING_PATH
        path = self.calculate_path_to_target(target_pose)

        if not path:
            goal_handle.abort()
            result.success = False
            result.message = 'Could not calculate path to target'
            self.is_walking = False
            return result

        # Execute walking along path
        self.current_state = WalkingState.EXECUTING_STEP

        for i, waypoint in enumerate(path):
            if goal_handle.is_cancel_requested:
                self.get_logger().info('Walking goal canceled')
                goal_handle.canceled()
                result.success = False
                result.message = 'Goal canceled by user'
                self.is_walking = False
                self.publish_stop_command()
                return result

            # Check for safety during execution
            if not self.continuous_safety_check():
                self.get_logger().error('Safety check failed during walking, aborting')
                goal_handle.abort()
                result.success = False
                result.message = 'Safety violation during walking'
                self.is_walking = False
                self.publish_stop_command()
                return result

            # Execute step to waypoint
            success = self.execute_step_to_waypoint(waypoint, walk_speed, step_height)

            if not success:
                goal_handle.abort()
                result.success = False
                result.message = f'Failed to reach waypoint {i}'
                self.is_walking = False
                self.publish_stop_command()
                return result

            # Update feedback
            feedback_msg.current_pose = self.get_current_pose()
            feedback_msg.distance_remaining = self.calculate_distance_to_target(target_pose)
            feedback_msg.percentage_complete = (i + 1) / len(path) * 100.0
            feedback_msg.current_state = str(self.current_state)

            goal_handle.publish_feedback(feedback_msg)

            # Small delay between steps to allow for stabilization
            time.sleep(0.1)

        # Complete walking task
        self.current_state = WalkingState.COMPLETING
        self.is_walking = False

        # Verify final position
        final_distance = self.calculate_distance_to_target(target_pose)
        if final_distance < 0.1:  # Within 10cm of target
            goal_handle.succeed()
            result.success = True
            result.message = f'Successfully reached target with final distance: {final_distance:.3f}m'
        else:
            goal_handle.abort()
            result.success = False
            result.message = f'Reached path end but final distance: {final_distance:.3f}m exceeds tolerance'

        # Publish completion status
        status_msg = Bool()
        status_msg.data = False  # Not walking anymore
        self.status_publisher.publish(status_msg)

        self.get_logger().info(f'Walking goal completed: {result.message}')

        return result

    def is_goal_reachable(self, target_pose):
        """
        Check if the target pose is reachable by the humanoid.
        """
        # This would implement reachability checking based on humanoid kinematics
        # For now, we'll do a simple distance check
        current_pose = self.get_current_pose()
        distance = math.sqrt(
            (target_pose.position.x - current_pose.position.x)**2 +
            (target_pose.position.y - current_pose.position.y)**2 +
            (target_pose.position.z - current_pose.position.z)**2
        )

        # Assume humanoid can walk up to 10 meters
        return distance <= 10.0

    def pre_walk_safety_check(self):
        """
        Perform safety checks before starting to walk.
        """
        # Check if all critical joints are available and within safe limits
        critical_joints = [
            'left_hip_pitch', 'right_hip_pitch',
            'left_knee', 'right_knee',
            'left_ankle_pitch', 'right_ankle_pitch'
        ]

        for joint in critical_joints:
            if joint not in self.current_joint_positions:
                self.get_logger().error(f'Critical joint {joint} not available')
                return False

        # Check IMU data for reasonable values
        if self.imu_data:
            # Check for extreme accelerations that might indicate the robot is falling
            acc_magnitude = math.sqrt(
                self.imu_data.linear_acceleration.x**2 +
                self.imu_data.linear_acceleration.y**2 +
                self.imu_data.linear_acceleration.z**2
            )

            if acc_magnitude > 20.0:  # Unreasonable acceleration
                self.get_logger().error(f'Extreme acceleration detected: {acc_magnitude:.2f}')
                return False

        return True

    def continuous_safety_check(self):
        """
        Perform safety checks during walking execution.
        """
        # Similar to pre-walk check but during execution
        if self.imu_data:
            # Check for signs of instability
            acc_magnitude = math.sqrt(
                self.imu_data.linear_acceleration.x**2 +
                self.imu_data.linear_acceleration.y**2 +
                self.imu_data.linear_acceleration.z**2
            )

            # If acceleration is too high, robot may be falling
            if acc_magnitude > 15.0:
                self.get_logger().error(f'High acceleration during walking: {acc_magnitude:.2f}')
                return False

        # Check joint positions for extreme values that might indicate problems
        for joint_name, position in self.current_joint_positions.items():
            if abs(position) > 3.0:  # Extreme joint position
                self.get_logger().warn(f'Extreme position for {joint_name}: {position}')

        return True

    def calculate_path_to_target(self, target_pose):
        """
        Calculate path from current position to target.
        This is a simplified implementation - real path planning would be more complex.
        """
        current_pose = self.get_current_pose()

        # Simple straight-line path with intermediate waypoints
        distance = math.sqrt(
            (target_pose.position.x - current_pose.position.x)**2 +
            (target_pose.position.y - current_pose.position.y)**2
        )

        if distance < 0.1:  # Already at target
            return []

        # Create waypoints every 0.3 meters
        num_waypoints = max(1, int(distance / 0.3))
        path = []

        for i in range(1, num_waypoints + 1):
            fraction = i / num_waypoints
            waypoint = Pose()
            waypoint.position.x = current_pose.position.x + fraction * (target_pose.position.x - current_pose.position.x)
            waypoint.position.y = current_pose.position.y + fraction * (target_pose.position.y - current_pose.position.y)
            waypoint.position.z = current_pose.position.z + fraction * (target_pose.position.z - current_pose.position.z)
            # Orientation would be calculated based on walking direction
            path.append(waypoint)

        return path

    def execute_step_to_waypoint(self, waypoint, walk_speed, step_height):
        """
        Execute a single walking step to reach the specified waypoint.
        """
        # This would implement the actual walking control
        # For this example, we'll simulate the step execution

        # In a real implementation, this would:
        # 1. Generate appropriate walking pattern for the step
        # 2. Execute the pattern while monitoring balance
        # 3. Adjust based on sensor feedback
        # 4. Verify successful completion of the step

        # Simulate step execution time based on distance and speed
        current_pose = self.get_current_pose()
        step_distance = math.sqrt(
            (waypoint.position.x - current_pose.position.x)**2 +
            (waypoint.position.y - current_pose.position.y)**2
        )

        # Estimate time needed for step (simplified)
        step_time = step_distance / walk_speed if walk_speed > 0 else 1.0
        step_time = min(step_time, 2.0)  # Maximum 2 seconds per step

        # Simulate step execution with balance control
        start_time = time.time()
        while time.time() - start_time < step_time:
            # In real implementation, this would run balance control
            # and adjust stepping pattern based on feedback
            time.sleep(0.01)  # 100Hz balance control simulation

            # Check for interruptions
            if not self.is_walking:
                return False

        self.get_logger().debug(f'Step completed to waypoint: ({waypoint.position.x:.2f}, {waypoint.position.y:.2f})')
        return True

    def calculate_distance_to_target(self, target_pose):
        """
        Calculate distance from current position to target.
        """
        current_pose = self.get_current_pose()
        return math.sqrt(
            (target_pose.position.x - current_pose.position.x)**2 +
            (target_pose.position.y - current_pose.position.y)**2 +
            (target_pose.position.z - current_pose.position.z)**2
        )

    def get_current_pose(self):
        """
        Get current estimated pose of the humanoid (simplified).
        """
        # This would use more sophisticated pose estimation in a real system
        # For now, return a placeholder
        pose = Pose()
        pose.position = Point(x=0.0, y=0.0, z=0.0)  # Placeholder
        return pose

    def joint_state_callback(self, msg):
        """
        Update joint state information.
        """
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.current_joint_positions[name] = msg.position[i]
            if i < len(msg.velocity):
                self.current_joint_velocities[name] = msg.velocity[i]

    def imu_callback(self, msg):
        """
        Update IMU data for balance control.
        """
        self.imu_data = msg

    def publish_stop_command(self):
        """
        Publish zero commands to stop the robot safely.
        """
        stop_cmd = JointState()
        stop_cmd.name = list(self.current_joint_positions.keys())
        stop_cmd.position = [0.0] * len(stop_cmd.name)
        stop_cmd.velocity = [0.0] * len(stop_cmd.name)
        stop_cmd.effort = [0.0] * len(stop_cmd.name)
        stop_cmd.header.stamp = self.get_clock().now().to_msg()

        self.joint_command_publisher.publish(stop_cmd)

def main(args=None):
    rclpy.init(args=args)

    node = HumanoidWalkingActionServer()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Shutting down walking action server')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Action Clients for Humanoid Control

Here's an example of an action client that would interact with the walking action server:

```python
# humanoid_walking_action_client.py
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from humanoid_msgs.action import WalkToGoal
from geometry_msgs.msg import Pose, Point
import time
from typing import Optional

class HumanoidWalkingActionClient(Node):
    """
    Action client for commanding humanoid walking tasks.
    """

    def __init__(self):
        super().__init__('humanoid_walking_action_client')

        # Create action client
        self._action_client = ActionClient(
            self,
            WalkToGoal,
            'walk_to_goal'
        )

        self.get_logger().info('Humanoid walking action client initialized')

    def send_walk_goal(self, target_x: float, target_y: float, target_z: float = 0.0,
                      speed: float = 0.3, step_height: float = 0.05) -> bool:
        """
        Send a walking goal to the humanoid robot.

        Args:
            target_x: Target X position
            target_y: Target Y position
            target_z: Target Z position (default: 0.0)
            speed: Walking speed in m/s (default: 0.3)
            step_height: Step height in m (default: 0.05)

        Returns:
            True if goal was accepted and completed successfully, False otherwise
        """
        # Wait for action server
        if not self._action_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error('Action server not available')
            return False

        # Create goal message
        goal_msg = WalkToGoal.Goal()
        goal_msg.target_pose = Pose()
        goal_msg.target_pose.position = Point(x=target_x, y=target_y, z=target_z)
        goal_msg.speed = speed
        goal_msg.step_height = step_height

        # Send goal and wait for result
        self.get_logger().info(
            f'Sending walk goal to ({target_x:.2f}, {target_y:.2f}, {target_z:.2f}) '
            f'at speed {speed:.2f} m/s'
        )

        future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )

        # Wait for goal to be accepted
        rclpy.spin_until_future_complete(self, future)

        if future.result() is None:
            self.get_logger().error('Failed to send goal')
            return False

        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Goal was rejected by server')
            return False

        self.get_logger().info('Goal accepted, waiting for result...')

        # Get result future
        result_future = goal_handle.get_result_async()

        # Wait for result
        rclpy.spin_until_future_complete(self, result_future)

        if result_future.result() is None:
            self.get_logger().error('Failed to get result')
            return False

        result = result_future.result().result
        status = result_future.result().status

        self.get_logger().info(f'Walking result: {result.success}, {result.message}')

        return result.success

    def feedback_callback(self, feedback_msg):
        """
        Handle feedback during walking execution.
        """
        feedback = feedback_msg.feedback
        self.get_logger().debug(
            f'Walking progress: {feedback.percentage_complete:.1f}% complete, '
            f'distance remaining: {feedback.distance_remaining:.3f}m, '
            f'current state: {feedback.current_state}'
        )

    def send_cancel_request(self):
        """
        Send a cancel request for the current walking goal.
        """
        # This would implement cancellation of the current goal
        pass

def main(args=None):
    rclpy.init(args=args)

    client = HumanoidWalkingActionClient()

    # Example: Send a walking goal
    success = client.send_walk_goal(1.0, 1.0, 0.0, speed=0.2, step_height=0.05)

    if success:
        client.get_logger().info('Walking goal completed successfully!')
    else:
        client.get_logger().error('Walking goal failed')

    client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Real-time Performance Considerations

### Real-time Programming with rclpy

Humanoid robots have strict real-time requirements for stable control. Here are techniques for achieving real-time performance:

```python
# real_time_humanoid_control.py
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, QoSHistoryPolicy, QoSReliabilityPolicy
from sensor_msgs.msg import JointState, Imu
from geometry_msgs.msg import Twist
from std_msgs.msg import Bool
import time
import threading
import numpy as np
from collections import deque
import ctypes

class RealTimeHumanoidController(Node):
    """
    Real-time controller for humanoid robots with performance optimization.
    """

    def __init__(self):
        super().__init__('real_time_humanoid_controller')

        # Use minimal QoS for real-time performance
        rt_qos = QoSProfile(
            history=QoSHistoryPolicy.RMW_QOS_HISTORY_POLICY_KEEP_LAST,
            depth=1,  # Minimal history for real-time performance
            reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE,
        )

        # Create high-frequency publishers and subscribers
        self.joint_command_publisher = self.create_publisher(
            JointState, 'joint_commands', rt_qos
        )

        self.joint_state_subscriber = self.create_subscription(
            JointState, 'joint_states', self.joint_state_callback, rt_qos
        )

        self.imu_subscriber = self.create_subscription(
            Imu, 'imu/data', self.imu_callback, rt_qos
        )

        # Use a high-frequency timer for control (1000Hz = 1ms period)
        self.control_frequency = 1000  # Hz
        self.control_period = 1.0 / self.control_frequency

        self.control_timer = self.create_timer(
            self.control_period,
            self.real_time_control_loop,
            clock=self.get_clock()
        )

        # Initialize real-time data structures
        self.joint_positions = {}
        self.joint_velocities = {}
        self.imu_data = None

        # Use deques for efficient data storage and retrieval
        self.joint_history = {}  # Will store deques of joint values

        # Timing statistics for performance monitoring
        self.loop_times = deque(maxlen=1000)
        self.last_loop_time = time.time()

        # Control thread priority (Linux-specific)
        try:
            import os
            pid = os.getpid()
            # Set real-time scheduling policy (requires appropriate permissions)
            # os.sched_setscheduler(pid, os.SCHED_FIFO, os.sched_param(80))
        except AttributeError:
            # Not on Unix system
            pass
        except PermissionError:
            self.get_logger().warn('Insufficient permissions to set real-time scheduler')

        self.get_logger().info(
            f'Real-time humanoid controller initialized at {self.control_frequency}Hz'
        )

    def joint_state_callback(self, msg):
        """
        High-performance joint state callback.
        """
        # Store timestamp for performance analysis
        callback_start = time.time()

        # Update joint positions efficiently
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.joint_positions[name] = msg.position[i]

                # Maintain history for velocity estimation
                if name not in self.joint_history:
                    self.joint_history[name] = deque(maxlen=5)  # Keep last 5 values

                self.joint_history[name].append((msg.header.stamp, msg.position[i]))

        # Update velocities from history (approximation)
        for name in self.joint_positions:
            if name in self.joint_history and len(self.joint_history[name]) >= 2:
                # Estimate velocity from position history
                pos1, stamp1 = self.joint_history[name][-2]
                pos2, stamp2 = self.joint_history[name][-1]

                dt = (stamp2.nanosec - stamp1.nanosec) / 1e9
                if dt > 0:
                    vel = (pos2 - pos1) / dt
                    self.joint_velocities[name] = vel

        # Log performance if needed
        callback_time = time.time() - callback_start
        if callback_time > 0.001:  # More than 1ms
            self.get_logger().warn(f'Joint callback took {callback_time*1000:.2f}ms')

    def imu_callback(self, msg):
        """
        High-performance IMU callback.
        """
        self.imu_data = msg

    def real_time_control_loop(self):
        """
        Real-time control loop with strict timing requirements.
        """
        loop_start = time.time()

        # Calculate loop timing
        expected_end = self.last_loop_time + self.control_period
        current_time = time.time()

        # Check if we're running behind schedule
        if current_time > expected_end:
            timing_error = (current_time - expected_end) * 1000  # in ms
            self.get_logger().warn(f'Control loop behind schedule by {timing_error:.2f}ms')

        # Perform control calculations
        if self.joint_positions and self.imu_data:
            self.execute_real_time_control()

        # Record timing statistics
        loop_time = time.time() - loop_start
        self.loop_times.append(loop_time)
        self.last_loop_time = current_time

        # Monitor performance
        if len(self.loop_times) == 1000:  # Every 1000 iterations
            avg_loop_time = np.mean(list(self.loop_times)) * 1000  # Convert to ms
            max_loop_time = np.max(list(self.loop_times)) * 1000
            min_loop_time = np.min(list(self.loop_times)) * 1000

            self.get_logger().debug(
                f'Control loop timing - Avg: {avg_loop_time:.2f}ms, '
                f'Max: {max_loop_time:.2f}ms, Min: {min_loop_time:.2f}ms, '
                f'Target: {self.control_period*1000:.2f}ms'
            )

            # Clear some history to prevent memory buildup
            self.loop_times.clear()

    def execute_real_time_control(self):
        """
        Execute real-time control algorithm for humanoid robot.
        This method must complete within the control period.
        """
        # Balance control using IMU data
        if self.imu_data:
            balance_correction = self.calculate_balance_correction()

            # Apply corrections to joint commands
            self.apply_balance_control(balance_correction)

        # Trajectory following
        self.follow_trajectory()

        # Safety checks
        self.perform_safety_checks()

        # Publish commands
        self.publish_control_commands()

    def calculate_balance_correction(self):
        """
        Calculate balance correction from IMU data.
        Optimized for real-time execution.
        """
        if not self.imu_data:
            return np.zeros(3)

        # Extract orientation from IMU (optimized calculation)
        q = self.imu_data.orientation
        # Simplified roll/pitch calculation - optimized version
        w, x, y, z = q.w, q.x, q.y, q.z

        # Calculate roll and pitch directly from quaternion
        sinr_cosp = 2 * (w * x + y * z)
        cosr_cosp = 1 - 2 * (x * x + y * y)
        roll = np.arctan2(sinr_cosp, cosr_cosp)

        sinp = 2 * (w * y - z * x)
        # Check for gimbal lock
        if abs(sinp) >= 1:
            pitch = np.copysign(np.pi / 2, sinp)  # Use 90 degrees if out of range
        else:
            pitch = np.arcsin(sinp)

        # Return balance error
        return np.array([roll, pitch, 0.0])

    def apply_balance_control(self, balance_error):
        """
        Apply balance control corrections.
        Optimized for real-time performance.
        """
        # Simplified PD control for balance (real implementation would be more complex)
        p_gain = 50.0
        d_gain = 10.0

        # Apply corrections to ankle joints for balance
        ankle_joints = ['left_ankle_pitch', 'right_ankle_pitch',
                       'left_ankle_roll', 'right_ankle_roll']

        for joint_name in ankle_joints:
            if joint_name in self.joint_positions:
                # Calculate correction based on balance error
                correction = p_gain * balance_error[0]  # Simplified for demo
                new_position = self.joint_positions[joint_name] + correction * 0.001  # Small increment

                # Apply joint limits
                new_position = np.clip(new_position, -0.5, 0.5)
                self.joint_positions[joint_name] = new_position

    def follow_trajectory(self):
        """
        Follow predefined trajectory.
        Optimized for real-time execution.
        """
        # This would implement trajectory following logic
        pass

    def perform_safety_checks(self):
        """
        Perform fast safety checks during control loop.
        """
        # Check for extreme joint positions
        for joint_name, position in self.joint_positions.items():
            if abs(position) > 5.0:  # Extreme position
                self.get_logger().error(f'Extreme position for {joint_name}: {position}')
                self.emergency_stop()
                return

        # Check IMU for signs of falling
        if self.imu_data:
            lin_acc = self.imu_data.linear_acceleration
            acc_mag = np.sqrt(lin_acc.x**2 + lin_acc.y**2 + lin_acc.z**2)

            if acc_mag > 20.0:  # Likely falling
                self.get_logger().error(f'Extreme acceleration detected: {acc_mag:.2f}')
                self.emergency_stop()
                return

    def publish_control_commands(self):
        """
        Publish joint commands with minimal overhead.
        """
        cmd_msg = JointState()
        cmd_msg.header.stamp = self.get_clock().now().to_msg()
        cmd_msg.header.frame_id = 'base_link'

        # Use list comprehension for efficiency
        cmd_msg.name = list(self.joint_positions.keys())
        cmd_msg.position = list(self.joint_positions.values())
        cmd_msg.velocity = [0.0] * len(cmd_msg.position)  # Simplified
        cmd_msg.effort = [0.0] * len(cmd_msg.position)    # Simplified

        self.joint_command_publisher.publish(cmd_msg)

    def emergency_stop(self):
        """
        Emergency stop procedure for safety.
        """
        self.get_logger().fatal('EMERGENCY STOP ACTIVATED')

        # Publish zero commands
        zero_msg = JointState()
        zero_msg.name = list(self.joint_positions.keys())
        zero_msg.position = [0.0] * len(zero_msg.name)
        zero_msg.velocity = [0.0] * len(zero_msg.name)
        zero_msg.effort = [0.0] * len(zero_msg.name)
        zero_msg.header.stamp = self.get_clock().now().to_msg()

        self.joint_command_publisher.publish(zero_msg)

def main(args=None):
    rclpy.init(args=args)

    # Set higher process priority for real-time performance
    try:
        import psutil
        p = psutil.Process()
        p.nice(-10)  # Higher priority (Unix/Linux)
    except ImportError:
        pass  # psutil not available
    except (psutil.AccessDenied, AttributeError):
        pass  # Cannot set priority

    node = RealTimeHumanoidController()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Shutting down real-time controller')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Integration with Humanoid Control Systems

### Complete Integration Example

Here's an example that brings together all the advanced concepts:

```python
# humanoid_integrated_controller.py
import rclpy
from rclpy.node import Node
from rclpy.lifecycle import LifecycleNode, LifecycleState, TransitionCallbackReturn
from rclpy.action import ActionServer
from rclpy.qos import QoSProfile, QoSHistoryPolicy, QoSReliabilityPolicy
from sensor_msgs.msg import JointState, Imu
from geometry_msgs.msg import Twist
from std_msgs.msg import Bool, Float64
from humanoid_msgs.action import WalkToGoal
from builtin_interfaces.msg import Time
import time
import numpy as np
from collections import deque
import threading

class HumanoidIntegratedController(LifecycleNode):
    """
    Complete integrated controller demonstrating all advanced ROS 2 concepts
    for humanoid robot control: lifecycle management, parameters, actions, and real-time performance.
    """

    def __init__(self):
        super().__init__('humanoid_integrated_controller')

        # Initialize internal state
        self.joint_positions = {}
        self.joint_velocities = {}
        self.imu_data = None
        self.desired_velocity = Twist()
        self.is_operational = False
        self.emergency_stop_active = False

        # Data history for filtering and derivative calculation
        self.joint_history = {}
        self.imu_history = deque(maxlen=10)

        # Timing and performance monitoring
        self.last_control_time = None
        self.performance_stats = {
            'loop_times': deque(maxlen=1000),
            'cpu_usage': deque(maxlen=100),
            'memory_usage': deque(maxlen=100)
        }

        # Components to be initialized during lifecycle
        self.joint_command_publisher = None
        self.status_publisher = None
        self.joint_state_subscriber = None
        self.imu_subscriber = None
        self.cmd_vel_subscriber = None
        self.emergency_stop_subscriber = None
        self.control_timer = None
        self._action_server = None

        self.get_logger().info('Integrated humanoid controller initialized (unconfigured)')

    def on_configure(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Configure all components of the integrated controller.
        """
        self.get_logger().info('Configuring integrated humanoid controller')

        # Declare and validate parameters
        self.declare_parameter('control_frequency', 500, rclpy.Parameter.Type.INTEGER)
        self.declare_parameter('max_joint_velocity', 10.0, rclpy.Parameter.Type.DOUBLE)
        self.declare_parameter('balance_p_gain', 100.0, rclpy.Parameter.Type.DOUBLE)
        self.declare_parameter('balance_d_gain', 10.0, rclpy.Parameter.Type.DOUBLE)
        self.declare_parameter('safety.max_tilt_angle', 0.5, rclpy.Parameter.Type.DOUBLE)
        self.declare_parameter('safety.emergency_stop_timeout', 0.5, rclpy.Parameter.Type.DOUBLE)

        # Validate parameters
        control_freq = self.get_parameter('control_frequency').value
        if control_freq <= 0 or control_freq > 2000:
            self.get_logger().error(f'Invalid control frequency: {control_freq}')
            return TransitionCallbackReturn.FAILURE

        # Create publishers with appropriate QoS for real-time performance
        rt_qos = QoSProfile(
            history=QoSHistoryPolicy.RMW_QOS_HISTORY_POLICY_KEEP_LAST,
            depth=1,
            reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE
        )

        self.joint_command_publisher = self.create_publisher(
            JointState, 'joint_commands', rt_qos
        )

        self.status_publisher = self.create_publisher(Bool, 'robot_status', 10)

        # Create subscribers
        self.joint_state_subscriber = self.create_subscription(
            JointState, 'joint_states', self.joint_state_callback, rt_qos
        )

        self.imu_subscriber = self.create_subscription(
            Imu, 'imu/data', self.imu_callback, rt_qos
        )

        self.cmd_vel_subscriber = self.create_subscription(
            Twist, 'cmd_vel', self.cmd_vel_callback, 10
        )

        self.emergency_stop_subscriber = self.create_subscription(
            Bool, 'emergency_stop', self.emergency_stop_callback, 1
        )

        # Create action server
        self._action_server = ActionServer(
            self,
            WalkToGoal,
            'walk_to_goal',
            execute_callback=self.walk_execute_callback,
            callback_group=None,
            goal_callback=self.walk_goal_callback,
            cancel_callback=self.walk_cancel_callback
        )

        # Set up parameter callback
        self.add_on_set_parameters_callback(self.parameter_change_callback)

        self.get_logger().info('Integrated controller configured successfully')
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Activate the integrated controller.
        """
        self.get_logger().info('Activating integrated humanoid controller')

        # Activate publishers
        self.joint_command_publisher.on_activate()
        self.status_publisher.on_activate()

        # Start high-frequency control timer
        control_freq = self.get_parameter('control_frequency').value
        self.control_timer = self.create_timer(
            1.0 / control_freq,
            self.integrated_control_loop
        )

        self.is_operational = True
        self.last_control_time = self.get_clock().now()

        # Publish operational status
        status_msg = Bool()
        status_msg.data = True
        self.status_publisher.publish(status_msg)

        self.get_logger().info(f'Integrated controller activated at {control_freq}Hz')
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state: LifecycleState) -> TransitionCallbackReturn:
        """
        Deactivate the integrated controller.
        """
        self.get_logger().info('Deactivating integrated humanoid controller')

        if self.control_timer:
            self.control_timer.destroy()

        # Deactivate publishers
        self.joint_command_publisher.on_deactivate()
        self.status_publisher.on_deactivate()

        self.is_operational = False

        # Publish non-operational status
        status_msg = Bool()
        status_msg.data = False
        self.status_publisher.publish(status_msg)

        self.get_logger().info('Integrated controller deactivated')
        return TransitionCallbackReturn.SUCCESS

    def parameter_change_callback(self, parameters):
        """
        Handle parameter changes during operation.
        """
        result = rclpy.parameter.SetParametersResult()
        result.successful = True
        result.reason = 'Parameters updated successfully'

        for param in parameters:
            # Validate safety parameters
            if param.name == 'control_frequency':
                if param.value <= 0 or param.value > 2000:
                    result.successful = False
                    result.reason = 'Control frequency must be between 1 and 2000 Hz'
                    break
            elif param.name == 'max_joint_velocity':
                if param.value <= 0:
                    result.successful = False
                    result.reason = 'Max joint velocity must be positive'
                    break
            elif param.name.startswith('balance_'):
                if param.value < 0:
                    result.successful = False
                    result.reason = 'Balance gains must be non-negative'
                    break

        return result

    def joint_state_callback(self, msg):
        """
        Handle joint state messages with real-time considerations.
        """
        if not self.is_operational:
            return

        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.joint_positions[name] = msg.position[i]

            if i < len(msg.velocity):
                self.joint_velocities[name] = msg.velocity[i]

        # Update history for filtering and derivative calculation
        current_time = msg.header.stamp
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                if name not in self.joint_history:
                    self.joint_history[name] = deque(maxlen=5)
                self.joint_history[name].append((current_time, msg.position[i]))

    def imu_callback(self, msg):
        """
        Handle IMU messages for balance control.
        """
        if not self.is_operational:
            return

        self.imu_data = msg
        self.imu_history.append((self.get_clock().now(), msg))

    def cmd_vel_callback(self, msg):
        """
        Handle velocity commands.
        """
        if not self.is_operational:
            return

        self.desired_velocity = msg

    def emergency_stop_callback(self, msg):
        """
        Handle emergency stop commands.
        """
        if msg.data:
            self.emergency_stop_active = True
            self.get_logger().fatal('EMERGENCY STOP ACTIVATED - HALTING ALL MOTION')
            self.publish_emergency_stop_commands()
        else:
            if self.emergency_stop_active:
                self.emergency_stop_active = False
                self.get_logger().info('Emergency stop cleared')

    def integrated_control_loop(self):
        """
        Main integrated control loop combining all advanced concepts.
        """
        if not self.is_operational or self.emergency_stop_active:
            return

        loop_start = time.time()

        # Execute integrated control functions
        self.execute_balance_control()
        self.execute_trajectory_following()
        self.execute_safety_monitoring()
        self.execute_performance_monitoring()

        # Publish control commands
        self.publish_control_commands()

        # Update performance statistics
        loop_time = time.time() - loop_start
        self.performance_stats['loop_times'].append(loop_time)

        # Check for timing issues
        expected_period = 1.0 / self.get_parameter('control_frequency').value
        if loop_time > expected_period * 1.5:  # 50% over expected time
            self.get_logger().warn(f'Control loop exceeded timing by {(loop_time - expected_period)*1000:.2f}ms')

    def execute_balance_control(self):
        """
        Execute advanced balance control using parameters.
        """
        if not self.imu_data:
            return

        # Get balance control parameters
        p_gain = self.get_parameter('balance_p_gain').value
        d_gain = self.get_parameter('balance_d_gain').value
        max_tilt = self.get_parameter('safety.max_tilt_angle').value

        # Calculate balance error from IMU data
        balance_error = self.calculate_balance_error_from_imu()

        # Check for dangerous tilt angles
        if abs(balance_error) > max_tilt:
            self.get_logger().error(f'Dangerous tilt angle detected: {balance_error:.3f} > {max_tilt:.3f}')
            self.emergency_stop_active = True
            self.publish_emergency_stop_commands()
            return

        # Apply balance control with parameterized gains
        balance_correction = p_gain * balance_error

        # Apply corrections to appropriate joints (simplified example)
        ankle_joints = [name for name in self.joint_positions.keys() if 'ankle' in name]
        for joint_name in ankle_joints:
            if joint_name in self.joint_positions:
                current_pos = self.joint_positions[joint_name]
                new_pos = current_pos + balance_correction * 0.001  # Small scaling factor
                self.joint_positions[joint_name] = new_pos

    def calculate_balance_error_from_imu(self):
        """
        Calculate balance error from IMU data.
        """
        if not self.imu_data:
            return 0.0

        # Extract roll and pitch from quaternion
        q = self.imu_data.orientation
        sinr_cosp = 2 * (q.w * q.x + q.y * q.z)
        cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y)
        roll = np.arctan2(sinr_cosp, cosr_cosp)

        sinp = 2 * (q.w * q.y - q.z * q.x)
        if abs(sinp) >= 1:
            pitch = np.copysign(np.pi / 2, sinp)
        else:
            pitch = np.arcsin(sinp)

        # Combine roll and pitch for overall balance error
        return np.sqrt(roll*roll + pitch*pitch)

    def execute_trajectory_following(self):
        """
        Execute trajectory following based on velocity commands.
        """
        # This would implement complex trajectory generation
        # and following algorithms using humanoid kinematics
        pass

    def execute_safety_monitoring(self):
        """
        Execute continuous safety monitoring.
        """
        # Check joint limits
        max_velocity = self.get_parameter('max_joint_velocity').value
        for joint_name, velocity in self.joint_velocities.items():
            if abs(velocity) > max_velocity:
                self.get_logger().warn(f'Joint velocity limit exceeded for {joint_name}: {velocity}')
                # In a real system, this might trigger safety procedures

    def execute_performance_monitoring(self):
        """
        Execute performance monitoring and optimization.
        """
        # Monitor system resources
        try:
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent

            self.performance_stats['cpu_usage'].append(cpu_percent)
            self.performance_stats['memory_usage'].append(memory_percent)

            # Log performance if thresholds are exceeded
            if cpu_percent > 80:
                self.get_logger().warn(f'High CPU usage: {cpu_percent}%')

            if memory_percent > 80:
                self.get_logger().warn(f'High memory usage: {memory_percent}%')
        except ImportError:
            pass  # psutil not available

    def publish_control_commands(self):
        """
        Publish integrated control commands.
        """
        if not self.joint_command_publisher:
            return

        cmd_msg = JointState()
        cmd_msg.header.stamp = self.get_clock().now().to_msg()
        cmd_msg.header.frame_id = 'base_link'
        cmd_msg.name = list(self.joint_positions.keys())
        cmd_msg.position = list(self.joint_positions.values())
        cmd_msg.velocity = [0.0] * len(cmd_msg.position)
        cmd_msg.effort = [0.0] * len(cmd_msg.position)

        self.joint_command_publisher.publish(cmd_msg)

    def publish_emergency_stop_commands(self):
        """
        Publish emergency stop commands to halt all motion safely.
        """
        if self.joint_command_publisher:
            stop_msg = JointState()
            stop_msg.header.stamp = self.get_clock().now().to_msg()
            stop_msg.header.frame_id = 'base_link'
            stop_msg.name = list(self.joint_positions.keys())
            stop_msg.position = [0.0] * len(stop_msg.name)
            stop_msg.velocity = [0.0] * len(stop_msg.name)
            stop_msg.effort = [0.0] * len(stop_msg.name)

            self.joint_command_publisher.publish(stop_msg)

    # Action server callbacks
    def walk_goal_callback(self, goal_request):
        """Goal callback for walking action."""
        if self.emergency_stop_active:
            return rclpy.action.server.GoalResponse.REJECT
        return rclpy.action.server.GoalResponse.ACCEPT

    def walk_cancel_callback(self, goal_handle):
        """Cancel callback for walking action."""
        return rclpy.action.server.CancelResponse.ACCEPT

    def walk_execute_callback(self, goal_handle):
        """Execute callback for walking action."""
        # This would implement the walking action logic
        # For brevity, we'll return a simple result
        result = WalkToGoal.Result()
        result.success = True
        result.message = 'Walking action completed successfully'
        goal_handle.succeed()
        return result

def main(args=None):
    rclpy.init(args=args)

    node = HumanoidIntegratedController()

    # Example of transitioning through lifecycle states
    node.trigger_configure()
    node.trigger_activate()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Interrupted, initiating shutdown sequence')
    finally:
        # Properly transition through lifecycle states
        if hasattr(node, 'lifecycle_state'):
            if node.lifecycle_state.label == 'active':
                node.trigger_deactivate()
            if node.lifecycle_state.label == 'inactive':
                node.trigger_cleanup()
            if hasattr(node, '_action_server') and node._action_server:
                node._action_server.destroy()

        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Summary

This chapter has covered advanced ROS 2 concepts essential for humanoid robotics development:

1. **Lifecycle Nodes**: Implementing structured state management for safety-critical humanoid applications with proper initialization, activation, and shutdown procedures.

2. **Parameter Systems**: Dynamic configuration of humanoid robot behaviors with validation and runtime adjustment capabilities for control gains, safety limits, and operational parameters.

3. **Actions**: Asynchronous task execution with feedback and cancellation for complex humanoid behaviors like walking, manipulation, and calibration procedures.

4. **Real-time Performance**: Optimization techniques for achieving the timing requirements necessary for stable humanoid robot control, including efficient data structures, minimal QoS settings, and performance monitoring.

5. **Integrated Control**: Combining all advanced concepts into a comprehensive humanoid robot control system that demonstrates best practices for production robotics applications.

These advanced concepts enable the development of sophisticated humanoid robot systems that can handle complex state management, dynamic reconfiguration, and long-running tasks while maintaining the safety and real-time performance requirements essential for humanoid robotics applications.

Understanding these concepts is crucial for the subsequent modules, particularly when integrating with simulation environments, AI systems, and developing advanced control algorithms for humanoid robots.

## References

Paredis, F., Hawks, P. J., Goldfeder, C., & Allen, P. K. (2017). A perception-action learning framework for collaborative robot teams. *IEEE International Conference on Robotics and Automation (ICRA)*, 3351-3358.

Quigley, M., Gerkey, B., & Smart, W. D. (2009). ROS: An open-source Robot Operating System. *ICRA Workshop on Open Source Software*, 3(3.2), 5.

Macenski, S., Vrzakova, H., Pfeifer, T., et al. (2022). ROS 2 Design: Concepts, Status, and Tradeoffs. *IEEE Robotics & Automation Magazine*, 29(2), 28-37.

Siciliano, B., & Khatib, O. (2016). *Springer Handbook of Robotics* (2nd ed.). Springer.

Fedder, A., Viragh, C., Monroy, J., & Vincze, M. (2019). The challenge of simulating perception for robot navigation: An overview of benchmarking approaches. *IEEE Access*, 7, 104326-104340.